{"version":3,"sources":["components/CubingIcon/CubingIcon.jsx","logic/formats.js","logic/utils.js","logic/wcif.js","logic/roundtypes.js","logic/events.js","components/Competition/CompetitionMenu/CompetitionMenu.jsx","logic/countries.js","logic/import-export-wcif.js","logic/scrambles.js","components/Scrambles/ScrambleList.jsx","components/Competition/RoundPanel/RoundPanel.jsx","components/Competition/CompetitionInfo/CompetitionDetailsPanel.jsx","components/Competition/CompetitionInfo/MatchingScramblesPanel.jsx","components/Scrambles/ScrambleFileInfo.jsx","components/Competition/CompetitionInfo/UploadedScramblesPanel.jsx","components/Competition/CompetitionInfo/CompetitionInfo.jsx","components/Competition/Competition.jsx","logic/results.js","logic/xlsx-utils.js","components/ImportWCIF/ImportWCIF.jsx","components/App/App.jsx","index.js"],"names":["CubingIcon","_ref","eventId","props","Object","objectWithoutProperties","react_default","a","createElement","assign","style","fontSize","className","concat","formats","id","name","shortName","solveCount","cutoffFormats","sortBy","formatById","find","format","updateArrayInplace","arr","index","newElem","updateIn","object","updater","_ref2","toArray","property","properyChain","slice","length","Number","isInteger","objectSpread","defineProperty","flatMap","fn","reduce","xs","x","groupBy","obj","sortCompare","y","sort","sum","parseActivityCode","activityCode","_activityCode$match","match","_activityCode$match2","slicedToArray","e","r","g","roundNumber","parseInt","groupNumber","attemptNumber","registrantIdFromAttributes","persons","country","wcaId","p","registrantId","competitionLink","eventHasValidScrambles","event","rounds","every","roundHasValidScrambles","round","includes","keys","scrambleSets","s","roundTypes","rank","cellName","isFinal","roundTypeById","t","events","eventNameById","propertyById","sortWcifEvents","wcifEvents","wcifEvent","findIndex","roundTypeIdForRound","numberOfRounds","roundTypeId","cutoff","EventListItem","withStyles","root","color","& .cubing-icon, & svg","ListItem","useStyles","makeStyles","theme","item","paddingLeft","spacing","svg","& svg","CompetitionMenu","setSelectedRound","_useState","useState","_useState2","selectedEvent","setSelectedEvent","classes","List","dense","button","onClick","ListItemIcon","Info_default","ListItemText","primary","map","react","key","stopPropagation","components_CubingIcon_CubingIcon","Tooltip","title","ReportProblem_default","Collapse","in","timeout","unmountOnExit","classnames","countries","wca_states","states_lists","list","states","uniqueScrambleSetId","uniqueScrambleUploadedId","getUniqueScrambleSetId","getUniqueScrambleUploadedId","internalWcifToWcif","wcif","internalScramblesToWcifScrambles","importWcif","all","Math","max","apply","toConsumableArray","scrambleSheet","competitionName","generationUrl","generationDate","version","sheets","set","_scrambleSheet$sheets","internalSet","wcifScrambleToInternal","splitMultiFmAsWcif","push","extractedSheets","sheetName","scrambles","extraScrambles","prefixForIndex","sequence","generatedAttemptNumber","scrambleSetsForRound","usedScramblesId","uploadedScrambles","_parseActivityCode","firstMatchingSheets","up","filter","numberOfAttempts","usedScramblesIdsForEvent","updateMultiAndFm","scramble","scrambleSetId","splitMultiFm","transformUploadedScrambles","uploadedJson","filename","sheet","tnoodleSheetsToInternal","String","fromCharCode","scramblesByAttempt","forEach","number","groupIndex","_sheets$groupIndex$sc","scramblesToResultsGroups","group","DNDList","styled","minHeight","ScrambleListHeader","Grid","md","lg","align","Typography","variant","ScrambleWithPrefix","prefix","subtitle","secondary","ScrambleItem","DraggableScramble","_ref3","showPrefix","react_beautiful_dnd_esm","draggableId","provided","snapshot","ref","innerRef","draggableProps","dragHandleProps","isDragging","draggableStyle","background","ScrambleList_ScrambleWithPrefix","ScrambleList_ScrambleItem","ScrambleList","_ref4","holds","startsWith","droppableId","droppableProps","ScrambleList_ScrambleListHeader","ScrambleList_DraggableScramble","placeholder","SpacedPaper","marginBottom","Paper","attemptFromDroppable","elem","split","ListForGenericRound","Scrambles_ScrambleList","ListForAttemptBasedRound","nAttempts","attempts","Array","i","RoundPanel","_this","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","handleGenericMove","source","destination","_this$props","attachScramblesToRound","availableScrambles","state","splice","destScrambles","setState","handleAttemptBasedMove","_this$props2","destAttempt","k","handleScrambleMovement","result","prevProps","prevIds","join","_this$props3","onDragEnd","roundName","container","justify","padding","RoundPanel_ListForAttemptBasedRound","RoundPanel_ListForGenericRound","Component","LinkToNewPage","block","extraProps","Link","target","rel","HelperWithLink","CompetitionDetailsPanel_LinkToNewPage","href","CompetitionDetailsPanel","downloadWcifAction","downloadResultsJsonAction","uploadCompetitionIdAction","exportAvailable","paper","h","mb3","noValidate","autoComplete","TextField","label","value","onChange","ev","helperText","CompetitionDetailsPanel_HelperWithLink","margin","paragraph","ButtonGroup","aria-label","disabled","Button","GreenButton","palette","getContrastText","green","backgroundColor","&:hover","MatchingScramblesPanel","assignAction","clearAction","uploadAction","direction","accept","input","multiple","type","htmlFor","component","addJsonButton","paddingRight","fullWidth","FreeBreakfast_default","extendedIcon","Delete_default","expand","transform","transition","transitions","create","duration","shortest","expandOpen","card","NestedScrambleItem","ScrambleFileInfo","expanded","setExpanded","handleExpandClick","Card","CardHeader","action","IconButton","clsx","aria-expanded","ExpandMore_default","subheader","CardContent","UploadedScramblesPanel","Scrambles_ScrambleFileInfo","downloadFile","exporter","arguments","undefined","blob","Blob","JSON","stringify","blobURL","window","URL","createObjectURL","tmp","document","setAttribute","body","appendChild","click","display","width","marginTop","marginRight","CompetitionInfo","handleWcifChange","CompetitionInfo_CompetitionDetailsPanel","formatVersion","competitionId","countryId","iso2","gender","dob","birthdate","roundId","formatId","results","res","personId","position","ranking","best","average","groups","scrambleProgram","resultsProgram","internalWcifToResultsJson","CompetitionInfo_MatchingScramblesPanel","usedScrambleIdsByEvent","autoAssignScrambles","clearScrambles","CompetitionInfo_UploadedScramblesPanel","Competition","handleOnBeforeUnload","preventDefault","returnValue","uploadNewScramble","reader","FileReader","onload","newScramble","parse","onerror","alert","files","readAsText","eventIndex","roundIndex","selectedRoundId","addEventListener","removeEventListener","_this$state","used","usedIds","allScramblesForEvent","Competition_CompetitionMenu_CompetitionMenu","RoundPanel_RoundPanel","Competition_CompetitionInfo_CompetitionInfo","timeInSecToValue","resultString","parseFloat","timeToValue","asMove","_resultString$split","_resultString$split2","min","rest","timeInMinutesToValue","formatStringToId","Format: best of 1","Format: best of 2","Format: best of 3","Format: mean of 3","Format: average of 5","Format: average of 5 (removing best and worst)","expectedNumberOfAttemptsByFormat","1","2","3","m","attemptsFromResultRow","row","maxAttempts","bestForRow","avgForRow","avgDetected","Error","some","meanFromAttempts","roundWcifFromXlsx","roundFormat","roundType","advancementCondition","scrambleSetCount","timeLimit","marginLeft","loadSheetIntoWcif","jsonSheet","person","wcaUserId","registration","email","avatar","roles","assignments","personalBests","competitorLimit","qualification","xlsxOptions","header","raw","blankrows","ImportWCIF","handleWcifJSONLoad","xl","fontWeight","handleFileUploadChange","rABS","readAsBinaryString","wb","XLSX","read","sheetNames","SheetNames","schedule","utils","sheet_to_json","Sheets","readAsArrayBuffer","handleXlsxUploadChange","App","errors","json","_importWcif","_importWcif2","extractedScrambles","handleWcifUpdate","flexDirection","CssBaseline","Competition_Competition","components_ImportWCIF_ImportWCIF","ReactDOM","render","App_App","getElementById"],"mappings":"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","file":"static/js/main.499d3786.chunk.js","sourcesContent":["import React from 'react';\n\nconst CubingIcon = ({ eventId, ...props }) => (\n  <span\n    style={{ fontSize: 24 }}\n    className={`cubing-icon event-${eventId}`}\n    {...props}\n  />\n);\n\nexport default CubingIcon;\n","const formats = [\n  {\n    id: '1',\n    name: 'Best of 1',\n    shortName: 'Bo1',\n    solveCount: 1,\n    cutoffFormats: [],\n    sortBy: 'best',\n  },\n  {\n    id: '2',\n    name: 'Best of 2',\n    shortName: 'Bo2',\n    solveCount: 2,\n    cutoffFormats: ['1'],\n    sortBy: 'best',\n  },\n  {\n    id: '3',\n    name: 'Best of 3',\n    shortName: 'Bo3',\n    solveCount: 3,\n    cutoffFormats: ['1', '2'],\n    sortBy: 'best',\n  },\n  {\n    id: 'm',\n    name: 'Mean of 3',\n    shortName: 'Mo3',\n    solveCount: 3,\n    cutoffFormats: ['1', '2'],\n    sortBy: 'average',\n  },\n  {\n    id: 'a',\n    name: 'Average of 5',\n    shortName: 'Ao5',\n    solveCount: 5,\n    cutoffFormats: ['1', '2', '3'],\n    sortBy: 'average',\n  },\n];\n\nexport const formatById = id => formats.find(format => format.id === id);\n","const updateArrayInplace = (arr, index, newElem) => {\n  arr[index] = newElem;\n  return arr;\n};\n\n/**\n * Returns a copy of the object with the value at the specified path transformed by the update function.\n *\n * @param {Object} object\n * @param {Array} propertyChain\n * @param {Function} updater\n * @returns {Object}\n */\nexport const updateIn = (object, [property, ...properyChain], updater) =>\n  properyChain.length === 0\n    ? Number.isInteger(property)\n      ? updateArrayInplace(object, property, updater(object[property]))\n      : { ...object, [property]: updater(object[property]) }\n    : Number.isInteger(property)\n    ? updateArrayInplace(\n        object,\n        property,\n        updateIn(object[property], properyChain, updater)\n      )\n    : {\n        ...object,\n        [property]: updateIn(object[property], properyChain, updater),\n      };\n\n/**\n * Returns a copy of the object with the value at the specified path set to the given one.\n *\n * @param {Object} object\n * @param {Array} propertyChain\n * @param {*} value\n * @returns {Object}\n */\nexport const setIn = (object, properyChain, value) =>\n  updateIn(object, properyChain, () => value);\n\n/**\n * Returns a copy of the object with the value at the specified path merged with the given one.\n *\n * @param {Object} object\n * @param {Array} propertyChain\n * @param {Object} newValue\n * @returns {Object}\n */\nexport const mergeIn = (object, properyChain, newValue) =>\n  updateIn(object, properyChain, currentValue => ({\n    ...currentValue,\n    ...newValue,\n  }));\n\n/**\n * Returns a copy of the object with the array at the specified path mapped with the given function.\n *\n * @param {Object} object\n * @param {Array} propertyChain\n * @param {Object} mapper\n * @returns {Object}\n */\nexport const mapIn = (object, properyChain, mapper) =>\n  updateIn(object, properyChain, array => array && array.map(mapper));\n\n/**\n * Returns object's value at the specified path or the default value if it doesn't exist.\n *\n * @param {Object} object\n * @param {Array} propertyChain\n * @param {*} defaultValue\n * @returns {*}\n */\nexport const getIn = (\n  object,\n  [property, ...propertyChain],\n  defaultValue = null\n) =>\n  object\n    ? propertyChain.length === 0\n      ? object.hasOwnProperty(property)\n        ? object[property]\n        : defaultValue\n      : getIn(object[property], propertyChain, defaultValue)\n    : defaultValue;\n\n/**\n * Checks if the given value is an object.\n *\n * @param {*} value\n * @returns {boolean}\n */\nconst isObject = obj => obj === Object(obj);\n\n/**\n * When given an object, deeply checks if it doesn't contain null values.\n * Otherwise, checks if the given value is not null.\n *\n * @param {*} value\n * @returns {boolean}\n */\nexport const isPresentDeep = value =>\n  isObject(value) ? Object.values(value).every(isPresentDeep) : value != null;\n\n/**\n * Pluralizes a word according to the given number.\n * When no plural form given, uses singular form with an 's' appended.\n *\n * @param {number} count\n * @param {string} singular\n * @param {string} plural\n * @returns {string}\n */\nexport const pluralize = (count, singular, plural) =>\n  `${count} ${count === 1 ? singular : plural || singular + 's'}`;\n\n/**\n * Returns a new array with items summing up to 1, preserving elements proportionality.\n * When the given array is empty, returns an empty array.\n *\n * @param {Array} arr\n * @returns {Array}\n */\nexport const scaleToOne = arr => {\n  if (arr.length === 0) return [];\n  const arrSum = sum(arr);\n  return arr.map(x => (arrSum !== 0 ? x / arrSum : 1 / arr.length));\n};\n\n/**\n * Applies the given function to the elements and returns the first truthy value of these calls.\n *\n * @param {Array} arr\n * @returns {*}\n */\nexport const firstResult = (arr, fn) =>\n  arr.reduce((result, x) => result || fn(x), null);\n\nexport const flatMap = (arr, fn) => arr.reduce((xs, x) => xs.concat(fn(x)), []);\n\nexport const groupBy = (arr, fn) =>\n  arr.reduce(\n    (obj, x) => updateIn(obj, [fn(x)], xs => (xs || []).concat(x)),\n    {}\n  );\n\nexport const zip = (...arrs) =>\n  arrs.length === 0 ? [] : arrs[0].map((_, i) => arrs.map(arr => arr[i]));\n\nexport const findLast = (arr, predicate) =>\n  arr.reduceRight(\n    (found, x) => (found !== undefined ? found : predicate(x) ? x : undefined),\n    undefined\n  );\n\nexport const intersection = (xs, ys) => xs.filter(x => ys.includes(x));\n\nexport const difference = (xs, ys) => xs.filter(x => !ys.includes(x));\n\nexport const partition = (xs, fn) => [xs.filter(fn), xs.filter(x => !fn(x))];\n\nconst sortCompare = (x, y) => (x < y ? -1 : x > y ? 1 : 0);\n\nexport const sortBy = (arr, fn) =>\n  arr.slice().sort((x, y) => sortCompare(fn(x), fn(y)));\n\nexport const sortByArray = (arr, fn) => {\n  const values = new Map(\n    arr.map(x => [x, fn(x)])\n  ); /* Compute every value once. */\n  return arr\n    .slice()\n    .sort((x, y) =>\n      firstResult(zip(values.get(x), values.get(y)), ([a, b]) =>\n        sortCompare(a, b)\n      )\n    );\n};\n\nexport const chunk = (arr, size) =>\n  arr.length <= size\n    ? [arr]\n    : [arr.slice(0, size), ...chunk(arr.slice(size), size)];\n\nexport const times = (n, fn) =>\n  Array.from({ length: n }, (_, index) => fn(index));\n\nexport const uniq = arr => [...new Set(arr)];\n\nexport const sum = arr => arr.reduce((x, y) => x + y, 0);\n\nexport const pick = (obj, keys) =>\n  keys.reduce((newObj, key) => ({ ...newObj, [key]: obj[key] }), {});\n\nexport const inRange = (x, a, b) => a <= x && x <= b;\n\nexport const addMilliseconds = (isoString, milliseconds) =>\n  new Date(new Date(isoString).getTime() + milliseconds).toISOString();\n\nexport const isoTimeDiff = (first, second) =>\n  Math.abs(new Date(first) - new Date(second));\n\nexport const shortTime = (isoString, timeZone = 'UTC') =>\n  new Date(isoString).toLocaleTimeString('en-US', {\n    timeZone,\n    hour: 'numeric',\n    minute: 'numeric',\n  });\n\nexport const reorderArray = (arr, from, to) => {\n  const [removed] = arr.splice(from, 1);\n  arr.splice(to, 0, removed);\n};\n","import { formatById } from './formats';\nimport { groupBy } from './utils';\n\nexport const parseActivityCode = activityCode => {\n  const [, e, r, g, a] = activityCode.match(\n    /(\\w+)(?:-r(\\d+))?(?:-g(\\d+))?(?:-a(\\d+))?/\n  );\n  return {\n    eventId: e,\n    roundNumber: r && parseInt(r, 10),\n    groupNumber: g && parseInt(g, 10),\n    attemptNumber: a && parseInt(a, 10),\n  };\n};\n\nexport const registrantIdFromAttributes = (persons, name, country, wcaId) =>\n  persons.find(\n    p => p.name === name && p.country === country && p.wcaId === wcaId\n  ).registrantId;\n\nexport const competitionLink = id =>\n  `https://www.worldcubeassociation.org/competitions/${id}`;\n\nexport const competitionHasValidScrambles = wcif =>\n  wcif.events.every(e => eventHasValidScrambles(e));\n\nexport const eventHasValidScrambles = event =>\n  event.rounds.every(r => roundHasValidScrambles(event.id, r));\n\nexport const roundHasValidScrambles = (eventId, round) =>\n  // Just taking eventId to avoid some splitting of round.id\n  ['333mbf', '333fm'].includes(eventId)\n    ? Object.keys(groupBy(round.scrambleSets, s => s.attemptNumber)).length ===\n      formatById(round.format).solveCount\n    : round.scrambleSets.length !== 0;\n","const roundTypes = [\n  {\n    id: '0',\n    rank: 19,\n    name: 'Qualification round',\n    cellName: 'Qualification',\n    isFinal: 0,\n  },\n  {\n    id: '3',\n    rank: 79,\n    name: 'Semi Final',\n    cellName: 'Semi Final',\n    isFinal: 0,\n  },\n  {\n    id: 'b',\n    rank: 39,\n    name: 'B Final',\n    cellName: 'B Final',\n    isFinal: 0,\n  },\n  {\n    id: 'c',\n    rank: 90,\n    name: 'Combined Final',\n    cellName: 'Combined Final',\n    isFinal: 1,\n  },\n  {\n    id: 'd',\n    rank: 20,\n    name: 'Combined First round',\n    cellName: 'Combined First',\n    isFinal: 0,\n  },\n  {\n    id: 'e',\n    rank: 59,\n    name: 'Combined Second round',\n    cellName: 'Combined Second',\n    isFinal: 0,\n  },\n  {\n    id: 'f',\n    rank: 99,\n    name: 'Final',\n    cellName: 'Final',\n    isFinal: 1,\n  },\n  {\n    id: 'g',\n    rank: 70,\n    name: 'Combined Third round',\n    cellName: 'Combined Third',\n    isFinal: 0,\n  },\n  {\n    id: '1',\n    rank: 29,\n    name: 'First round',\n    cellName: 'First',\n    isFinal: 0,\n  },\n  {\n    id: '2',\n    rank: 50,\n    name: 'Second round',\n    cellName: 'Second',\n    isFinal: 0,\n  },\n  {\n    id: 'h',\n    rank: 10,\n    name: 'Combined qualification',\n    cellName: 'Combined qualification',\n    isFinal: 0,\n  },\n];\n\nexport const roundTypeById = id => roundTypes.find(t => t.id === id);\n\nexport const roundTypeFromCellName = cellName =>\n  roundTypes.find(t => cellName.includes(t.cellName));\n","import { sortBy } from './utils';\nimport { parseActivityCode } from './wcif';\nimport { roundTypeById } from './roundtypes';\n\nconst events = [\n  { id: '333', name: '3x3x3 Cube', shortName: '3x3' },\n  { id: '222', name: '2x2x2 Cube', shortName: '2x2' },\n  { id: '444', name: '4x4x4 Cube', shortName: '4x4' },\n  { id: '555', name: '5x5x5 Cube', shortName: '5x5' },\n  { id: '666', name: '6x6x6 Cube', shortName: '6x6' },\n  { id: '777', name: '7x7x7 Cube', shortName: '7x7' },\n  { id: '333bf', name: '3x3x3 Blindfolded', shortName: '3BLD' },\n  { id: '333fm', name: '3x3x3 Fewest Moves', shortName: 'FMC' },\n  { id: '333oh', name: '3x3x3 One-Handed', shortName: '3OH' },\n  { id: '333ft', name: '3x3x3 With Feet', shortName: '3WF' },\n  { id: 'minx', name: 'Megaminx', shortName: 'Minx' },\n  { id: 'pyram', name: 'Pyraminx', shortName: 'Pyra' },\n  { id: 'clock', name: 'Clock', shortName: 'Clock' },\n  { id: 'skewb', name: 'Skewb', shortName: 'Skewb' },\n  { id: 'sq1', name: 'Square-1', shortName: 'Sq1' },\n  { id: '444bf', name: '4x4x4 Blindfolded', shortName: '4BLD' },\n  { id: '555bf', name: '5x5x5 Blindfolded', shortName: '5BLD' },\n  { id: '333mbf', name: '3x3x3 Multi-Blind', shortName: 'MBLD' },\n];\n\nexport const eventNameById = eventId => propertyById('name', eventId);\n\nexport const shortEventNameById = eventId => propertyById('shortName', eventId);\n\nconst propertyById = (property, eventId) =>\n  events.find(event => event.id === eventId)[property];\n\nexport const sortWcifEvents = wcifEvents =>\n  sortBy(wcifEvents, wcifEvent =>\n    events.findIndex(event => event.id === wcifEvent.id)\n  );\n\nexport const roundTypeIdForRound = (numberOfRounds, round) => {\n  // This is the case if we loaded a XLSX!\n  if (round.roundTypeId) return round.roundTypeId;\n\n  let { roundNumber } = parseActivityCode(round.id);\n  if (roundNumber === numberOfRounds) {\n    return round.cutoff ? 'c' : 'f';\n  }\n  if (roundNumber === 1) {\n    return round.cutoff ? 'd' : '1';\n  }\n  if (roundNumber === 2) {\n    return round.cutoff ? 'e' : '2';\n  }\n  if (roundNumber === 3) {\n    return round.cutoff ? 'g' : '3';\n  }\n  return '<oops>';\n};\n\nexport const roundName = (numberOfRounds, round) => {\n  let { eventId } = parseActivityCode(round.id);\n  return `${eventNameById(eventId)} - ${\n    roundTypeById(roundTypeIdForRound(numberOfRounds, round)).name\n  }`;\n};\n","import React, { Fragment, useState } from 'react';\nimport Collapse from '@material-ui/core/Collapse';\nimport List from '@material-ui/core/List';\nimport ListItem from '@material-ui/core/ListItem';\nimport ListItemIcon from '@material-ui/core/ListItemIcon';\nimport ListItemText from '@material-ui/core/ListItemText';\nimport Tooltip from '@material-ui/core/Tooltip';\nimport { makeStyles, withStyles } from '@material-ui/core/styles';\nimport InfoIcon from '@material-ui/icons/Info';\nimport ReportProblemIcon from '@material-ui/icons/ReportProblem';\nimport classnames from 'classnames';\n\nimport CubingIcon from '../../CubingIcon/CubingIcon';\nimport {\n  eventHasValidScrambles,\n  roundHasValidScrambles,\n} from '../../../logic/wcif';\nimport { eventNameById, roundTypeIdForRound } from '../../../logic/events';\nimport { roundTypeById } from '../../../logic/roundtypes';\n\nconst EventListItem = withStyles({\n  root: {\n    color: 'black',\n    '& .cubing-icon, & svg': {\n      color: 'black',\n    },\n  },\n})(ListItem);\n\nconst useStyles = makeStyles(theme => ({\n  item: {\n    paddingLeft: theme.spacing(4),\n  },\n  svg: {\n    '& svg': {\n      color: 'red',\n    },\n  },\n}));\n\nconst CompetitionMenu = ({ events, setSelectedRound }) => {\n  const [selectedEvent, setSelectedEvent] = useState(null);\n  const classes = useStyles();\n  return (\n    <List dense={true}>\n      <EventListItem button onClick={() => setSelectedRound(null)}>\n        <ListItemIcon>\n          <InfoIcon />\n        </ListItemIcon>\n        <ListItemText primary=\"Information\" />\n      </EventListItem>\n      {events.map(event => (\n        <Fragment key={event.id}>\n          <EventListItem\n            button\n            onClick={e => {\n              setSelectedEvent(selectedEvent === event.id ? null : event.id);\n              e.stopPropagation();\n            }}\n          >\n            <ListItemIcon>\n              <CubingIcon eventId={event.id} />\n            </ListItemIcon>\n            <ListItemText primary={eventNameById(event.id)} />\n            {!eventHasValidScrambles(event) && (\n              <ListItemIcon className={classes.svg}>\n                <Tooltip title=\"Missing scrambles\">\n                  <ReportProblemIcon />\n                </Tooltip>\n              </ListItemIcon>\n            )}\n          </EventListItem>\n          <Collapse\n            in={selectedEvent === event.id}\n            timeout=\"auto\"\n            unmountOnExit\n          >\n            <List dense={true}>\n              {event.rounds.map(round => (\n                <ListItem\n                  key={round.id}\n                  button\n                  className={classnames(classes.svg, classes.item)}\n                  onClick={() => setSelectedRound(round.id)}\n                >\n                  <ListItemText\n                    primary={\n                      roundTypeById(\n                        roundTypeIdForRound(event.rounds.length, round)\n                      ).name\n                    }\n                  />\n                  {!roundHasValidScrambles(event.id, round) && (\n                    <ListItemIcon>\n                      <Tooltip title=\"Missing scrambles\">\n                        <ReportProblemIcon />\n                      </Tooltip>\n                    </ListItemIcon>\n                  )}\n                </ListItem>\n              ))}\n            </List>\n          </Collapse>\n        </Fragment>\n      ))}\n    </List>\n  );\n};\n\nexport default CompetitionMenu;\n","import { flatMap } from './utils';\nimport wca_states from '../wca_data/wca-states.json';\n\nconst countries = flatMap(wca_states.states_lists, list => list.states);\n\nexport const countryByIso2 = iso2 =>\n  countries.find(country => country.iso2 === iso2);\n\nexport const countryById = id => countries.find(country => country.id === id);\n","import { internalScramblesToWcifScrambles } from './scrambles';\nimport {\n  scramblesToResultsGroups,\n  wcifScrambleToInternal,\n  splitMultiFmAsWcif,\n} from './scrambles';\nimport { countryById } from './countries';\nimport { flatMap, updateIn } from './utils';\nimport { sortWcifEvents, roundTypeIdForRound } from './events';\nimport { parseActivityCode } from './wcif';\n\nlet uniqueScrambleSetId = 1;\nlet uniqueScrambleUploadedId = 1;\n\nexport const getUniqueScrambleSetId = () => uniqueScrambleSetId++;\nexport const getUniqueScrambleUploadedId = () => uniqueScrambleUploadedId++;\n\nexport const internalWcifToResultsJson = (wcif, version) => ({\n  formatVersion: 'WCA Competition 0.3',\n  competitionId: wcif.id,\n  persons: wcif.persons.map(p => ({\n    id: p.registrantId,\n    name: p.name,\n    wcaId: p.wcaId || '',\n    countryId: countryById(p.country).iso2,\n    gender: p.gender || '',\n    dob: p.birthdate,\n  })),\n  events: wcif.events.map(e => ({\n    eventId: e.id,\n    rounds: e.rounds.map(r => ({\n      roundId: roundTypeIdForRound(e.rounds.length, r),\n      formatId: r.format,\n      results: r.results.map(res => ({\n        personId: res.personId,\n        position: res.ranking,\n        results: res.attempts.map(a => a.result),\n        best: res.best,\n        average: res.average,\n      })),\n      groups: scramblesToResultsGroups(\n        internalScramblesToWcifScrambles(e.id, r.scrambleSets)\n      ),\n    })),\n  })),\n  // TODO: make sure that only one tnoodle was used, then add an explicit field for that?\n  scrambleProgram: wcif.scrambleProgram,\n  resultsProgram: `Scrambles Matcher ${version}`,\n});\n\nexport const internalWcifToWcif = wcif => ({\n  // We only alter the scrambles, so make them right wrt the WCIF.\n  ...wcif,\n  events: wcif.events.map(e => ({\n    ...e,\n    rounds: e.rounds.map(r => ({\n      ...r,\n      scrambleSets: internalScramblesToWcifScrambles(e.id, r.scrambleSets),\n    })),\n  })),\n});\n\nexport const importWcif = wcif => {\n  // Perform a few changes such as sorting the events, and extracting scrambles\n  // sheets.\n\n  wcif = updateIn(wcif, ['events'], sortWcifEvents);\n  let all = flatMap(\n    flatMap(wcif.events, e => e.rounds),\n    r => r.scrambleSets || []\n  );\n  uniqueScrambleSetId =\n    all.length === 0 ? 1 : Math.max(...all.map(s => s.id)) + 1;\n\n  let scrambleSheet = {\n    id: uniqueScrambleUploadedId,\n    competitionName: `${uniqueScrambleUploadedId}: Scrambles for ${wcif.name}`,\n    generationUrl: 'unknown',\n    generationDate: 'unknown',\n    version: 'unknown',\n    sheets: [],\n  };\n\n  wcif = {\n    ...wcif,\n    events: wcif.events.map(e => ({\n      ...e,\n      rounds: e.rounds.map(r => {\n        let sheets = (r.scrambleSets || []).map((set, index) => {\n          let internalSet = wcifScrambleToInternal(\n            e.id,\n            parseActivityCode(r.id).roundNumber,\n            scrambleSheet.competitionName,\n            set,\n            index\n          );\n          if (['333fm', '333mbf'].includes(e.id)) {\n            internalSet = splitMultiFmAsWcif(internalSet);\n            scrambleSheet.sheets.push(...internalSet);\n          } else {\n            scrambleSheet.sheets.push(internalSet);\n          }\n          return internalSet;\n        });\n        return {\n          ...r,\n          scrambleSets: flatMap(sheets, s => s),\n        };\n      }),\n    })),\n  };\n  let extractedSheets = [];\n  if (scrambleSheet.sheets.length !== 0) {\n    uniqueScrambleUploadedId++;\n    extractedSheets.push(scrambleSheet);\n  }\n\n  // Return an element to add to \"uploadedscrambles\", and the processed wcif.\n  return [wcif, extractedSheets];\n};\n","import { flatMap, updateIn, groupBy, sortBy } from './utils';\nimport { parseActivityCode } from './wcif';\nimport { getUniqueScrambleSetId } from './import-export-wcif';\nimport { formatById } from './formats';\nimport { eventNameById } from './events';\n\n// The WCIF defines the following fields:\n// { id, scrambles: [], extraScrambles: [] }\n// Internally we want to store a couple more information:\n// {\n//   sheetName: String, title: String, generatedAttemptNumber: null|Integer,\n//   eventId: String, roundNumber: Integer\n// }\n// This will let us easily (automatically) match and display scrambles in the WCIF.\n// Keeping in mind we'll need to support loading scrambles from the uploaded WCIF!\nconst tnoodleSheetsToInternal = (filename, sheets) =>\n  sheets.map(sheet => ({\n    id: getUniqueScrambleSetId(),\n    scrambles: sheet.scrambles || [],\n    extraScrambles: sheet.extraScrambles || [],\n    title: sheet.title,\n    sheetName: filename,\n    generatedAttemptNumber: sheet.generatedAttemptNumber,\n    eventId: sheet.event,\n    roundNumber: sheet.round,\n  }));\n\nexport const wcifScrambleToInternal = (\n  eventId,\n  roundNumber,\n  sheetName,\n  set,\n  index\n) => ({\n  id: set.id,\n  scrambles: set.scrambles || [],\n  extraScrambles: set.extraScrambles || [],\n  title: `${eventNameById(\n    eventId\n  )} - Round ${roundNumber} - Set ${prefixForIndex(index)}`,\n  sheetName: sheetName,\n  eventId: eventId,\n  roundNumber: roundNumber,\n});\n\nexport const splitMultiFmAsWcif = set => {\n  let attemptNumber = 1;\n  // Split the scramble to have one object per attempt (will be useful later ;))\n  return set.scrambles.map(sequence => ({\n    ...set,\n    id: getUniqueScrambleSetId(),\n    scrambles: [sequence],\n    title: `${set.title} Attempt ${attemptNumber}`,\n    attemptNumber: attemptNumber,\n    generatedAttemptNumber: attemptNumber++,\n  }));\n};\n\nconst splitMultiFm = scramble => {\n  let attemptNumber = 1;\n  // Split the scramble to have one object per attempt (will be useful later ;))\n  return scramble.scrambles.map(sequence => ({\n    ...scramble,\n    scrambles: [sequence],\n    title: `${scramble.title} Attempt ${attemptNumber}`,\n    scrambleSetId: `${scramble.scrambleSetId}-a${attemptNumber}`,\n    generatedAttemptNumber: attemptNumber++,\n  }));\n};\n\nconst scrambleSetsForRound = (usedScramblesId, round, uploadedScrambles) => {\n  // We don't want to overwrite existing scrambles,\n  // so for all rounds *without* scramble we:\n  //   - for all scramble in uploadedScrambles (in order they were uploaded):\n  //     - look for a set of matching (event, round number)\n  // This way if we ever upload multiple sets of scramble for the same round\n  // we just assign the first one (as the others are likely extra scrambles used\n  // in rounds we can't figure out programatically !).\n  // We also want to return a new WCIF as the wcif passed is most likely taken\n  // from a React state.\n  const { eventId, roundNumber } = parseActivityCode(round.id);\n  let firstMatchingSheets = [];\n  uploadedScrambles.find(up => {\n    firstMatchingSheets = up.sheets.filter(\n      s =>\n        !usedScramblesId.includes(s.id) &&\n        s.eventId === eventId &&\n        s.roundNumber === roundNumber\n    );\n    return firstMatchingSheets.length !== 0;\n  });\n  // We don't actually need to update the usedScramblesId, because we never try to\n  // get the same eventId/roundNumber again, so usedScramblesId only need to\n  // contain the scrambles in use before the autoAssign thing.\n  if (['333fm', '333mbf'].includes(eventId)) {\n    // Select scrambles which match the attempt number(s) expected,\n    // and assign the attemptNumber from the generated number\n    let numberOfAttempts = formatById(round.format).solveCount;\n    return firstMatchingSheets\n      .filter(s => s.generatedAttemptNumber <= numberOfAttempts)\n      .map(s => ({\n        ...s,\n        attemptNumber: s.generatedAttemptNumber,\n      }));\n  } else {\n    return firstMatchingSheets;\n  }\n};\n\nexport const allScramblesForEvent = (scrambles, eventId, usedIds) =>\n  flatMap(scrambles, scramble =>\n    scramble.sheets.filter(\n      s => s.eventId === eventId && !usedIds.includes(s.id)\n    )\n  );\n\nexport const usedScramblesIdsForEvent = (events, eventId) =>\n  flatMap(\n    flatMap(events.filter(e => e.id === eventId), e =>\n      flatMap(e.rounds, r => r.scrambleSets)\n    ),\n    s => s.id\n  );\n\nexport const updateMultiAndFm = scrambles =>\n  flatMap(scrambles, s =>\n    s.event === '333fm' || s.event === '333mbf' ? splitMultiFm(s) : s\n  );\n\nexport const transformUploadedScrambles = uploadedJson => {\n  const updater = sheets =>\n    tnoodleSheetsToInternal(uploadedJson.competitionName, sheets);\n  return updateIn(uploadedJson, ['sheets'], updater);\n};\n\n// 65 is the char code for 'A'\nexport const prefixForIndex = index => String.fromCharCode(65 + index);\n\nexport const internalScramblesToWcifScrambles = (eventId, scrambles) => {\n  if (scrambles.length === 0) return scrambles;\n  if (eventId === '333mbf') {\n    // For all attempts, we want to push each of the scramble sequences to\n    // their corresponding groups.\n    let scramblesByAttempt = groupBy(scrambles, s => s.attemptNumber);\n    let sheets = [];\n    Object.keys(scramblesByAttempt)\n      .sort()\n      .forEach(number =>\n        scramblesByAttempt[number].forEach((sheet, groupIndex) => {\n          if (groupIndex >= sheets.length) {\n            // Create a sheet for group\n            sheets.push({\n              id: sheet.id,\n              scrambles: [...sheet.scrambles],\n              extraScrambles: [],\n            });\n          } else {\n            // Push the attempt to the group\n            sheets[groupIndex].scrambles.push(...sheet.scrambles);\n          }\n        })\n      );\n    return sheets;\n  } else if (eventId === '333fm') {\n    // We can't track yet in the WCIF which scramble was for witch attempt,\n    // so let's just sort them by attempt id and combine them in one\n    // scramble sheet.\n    // There is usually only one group for FM, the only case where we would\n    // like more scramble than expected is when something terrible happened\n    // and an extra was needed.\n    return [\n      {\n        id: scrambles[0].id,\n        scrambles: flatMap(\n          sortBy(scrambles, s => s.attemptNumber),\n          s => s.scrambles\n        ),\n        extraScrambles: [],\n      },\n    ];\n  }\n  return scrambles.map(set => ({\n    id: set.id,\n    scrambles: set.scrambles,\n    extraScrambles: set.extraScrambles,\n  }));\n};\n\nexport const autoAssignScrambles = (wcif, uploadedScrambles) => {\n  let usedScrambleIdsByEvent = {};\n  wcif.events.forEach(e => {\n    usedScrambleIdsByEvent[e.id] = usedScramblesIdsForEvent(wcif.events, e.id);\n  });\n  return {\n    ...wcif,\n    events: wcif.events.map(e => ({\n      ...e,\n      rounds: e.rounds.map(r => ({\n        ...r,\n        scrambleSets:\n          r.scrambleSets.length === 0\n            ? scrambleSetsForRound(\n                usedScrambleIdsByEvent[e.id],\n                r,\n                uploadedScrambles\n              )\n            : r.scrambleSets,\n      })),\n    })),\n  };\n};\n\nexport const clearScrambles = wcif => ({\n  ...wcif,\n  events: wcif.events.map(e => ({\n    ...e,\n    rounds: e.rounds.map(r => ({\n      ...r,\n      scrambleSets: [],\n    })),\n  })),\n});\n\nexport const scramblesToResultsGroups = scrambles =>\n  scrambles.map((sheet, index) => ({\n    group: prefixForIndex(index),\n    scrambles: sheet.scrambles,\n    extraScrambles: sheet.extraScrambles || [],\n  }));\n","import React, { Fragment } from 'react';\nimport Grid from '@material-ui/core/Grid';\nimport List from '@material-ui/core/List';\nimport ListItem from '@material-ui/core/ListItem';\nimport ListItemText from '@material-ui/core/ListItemText';\nimport Typography from '@material-ui/core/Typography';\nimport { Droppable, Draggable } from 'react-beautiful-dnd';\nimport { styled } from '@material-ui/styles';\n\nimport { prefixForIndex } from '../../logic/scrambles';\n\nconst DNDList = styled(List)({\n  minHeight: '100px',\n});\n\nconst getItemStyle = (isDragging, draggableStyle) => ({\n  // styles we need to apply on draggables\n  ...draggableStyle,\n\n  ...(isDragging && {\n    background: 'rgb(235,235,235)',\n  }),\n});\n\nconst ScrambleListHeader = () => (\n  <ListItem>\n    <Grid item xs={6} md={4} lg={2} align=\"center\">\n      <Typography variant=\"h5\">Group</Typography>\n    </Grid>\n    <Grid item xs={6} md={8} lg={10} align=\"right\">\n      <Typography variant=\"h5\">Scramble sheet</Typography>\n    </Grid>\n  </ListItem>\n);\n\nconst ScrambleWithPrefix = ({ prefix, title, subtitle }) => (\n  <Fragment>\n    <Grid item xs={6} md={4} lg={2}>\n      <ListItemText primary={prefix} align=\"center\" />\n    </Grid>\n    <Grid item xs={6} md={8} lg={10} align=\"right\">\n      <ListItemText primary={title} secondary={subtitle} />\n    </Grid>\n  </Fragment>\n);\n\nconst ScrambleItem = ({ title, subtitle }) => (\n  <Grid item xs={12}>\n    <ListItemText primary={title} secondary={subtitle} />\n  </Grid>\n);\n\nconst DraggableScramble = ({ s, index, showPrefix }) => (\n  <Draggable draggableId={s.id} index={index}>\n    {(provided, snapshot) => (\n      <ListItem\n        button\n        ref={provided.innerRef}\n        {...provided.draggableProps}\n        {...provided.dragHandleProps}\n        style={getItemStyle(snapshot.isDragging, provided.draggableProps.style)}\n      >\n        {showPrefix && !snapshot.isDragging ? (\n          <ScrambleWithPrefix\n            prefix={prefixForIndex(index)}\n            title={s.title}\n            subtitle={`From ${s.sheetName}`}\n          />\n        ) : (\n          <ScrambleItem title={s.title} subtitle={`From ${s.sheetName}`} />\n        )}\n      </ListItem>\n    )}\n  </Draggable>\n);\n\nconst ScrambleList = ({ scrambles, holds, round }) => {\n  let showPrefix = holds.startsWith('round') && !round.id.startsWith('333fm');\n  return (\n    <Droppable droppableId={holds}>\n      {(provided, snapshot) => (\n        <DNDList {...provided.droppableProps} ref={provided.innerRef}>\n          {showPrefix && <ScrambleListHeader />}\n          {scrambles.map((s, index) => (\n            <DraggableScramble\n              key={s.id}\n              s={s}\n              index={index}\n              showPrefix={showPrefix}\n            />\n          ))}\n          {false && scrambles.length === 0 && (\n            <ListItem key={0}>No scrambles</ListItem>\n          )}\n          {provided.placeholder}\n        </DNDList>\n      )}\n    </Droppable>\n  );\n};\n\nexport default ScrambleList;\n","import React, { Component, Fragment } from 'react';\nimport Paper from '@material-ui/core/Paper';\nimport Grid from '@material-ui/core/Grid';\nimport Typography from '@material-ui/core/Typography';\nimport { DragDropContext } from 'react-beautiful-dnd';\nimport { withStyles } from '@material-ui/core/styles';\n\nimport ScrambleList from '../../Scrambles/ScrambleList';\nimport { groupBy, flatMap } from '../../../logic/utils';\nimport { roundName } from '../../../logic/events';\nimport { formatById } from '../../../logic/formats';\n\nconst SpacedPaper = withStyles(theme => ({\n  root: {\n    marginBottom: theme.spacing(4),\n  },\n}))(Paper);\n\nconst attemptFromDroppable = elem => parseInt(elem.droppableId.split('-')[1]);\n\nconst ListForGenericRound = ({ round }) => (\n  <Paper>\n    <Typography variant=\"h4\">Used for round</Typography>\n    <ScrambleList scrambles={round.scrambleSets} holds=\"round\" round={round} />\n  </Paper>\n);\n\nconst ListForAttemptBasedRound = ({ round }) => {\n  const nAttempts = formatById(round.format).solveCount;\n  let attempts = [...Array(nAttempts).keys()].map(i => ++i);\n  return (\n    <Fragment>\n      {attempts.map(index => (\n        <SpacedPaper key={index}>\n          <Typography variant=\"h4\">Used for attempt {index}</Typography>\n          <ScrambleList\n            scrambles={round.scrambleSets.filter(\n              s => s.attemptNumber === index\n            )}\n            holds={`round-${index}`}\n            round={round}\n          />\n        </SpacedPaper>\n      ))}\n    </Fragment>\n  );\n};\n\nexport default class RoundPanel extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      availableScrambles: this.props.availableScrambles,\n    };\n  }\n\n  componentDidUpdate(prevProps) {\n    let prevIds = this.state.availableScrambles.map(s => s.id).sort();\n    let newIds = this.props.availableScrambles.map(s => s.id).sort();\n\n    if (newIds.join('') !== prevIds.join('')) {\n      this.setState({\n        availableScrambles: this.props.availableScrambles,\n      });\n    }\n  }\n\n  handleGenericMove = (source, destination) => {\n    const { round, attachScramblesToRound } = this.props;\n    const { availableScrambles } = this.state;\n    // Whatever we do, we just need to update the parent state\n    let scrambles =\n      source.droppableId === 'available'\n        ? availableScrambles\n        : round.scrambleSets;\n    let scramble = scrambles.splice(source.index, 1)[0];\n\n    let destScrambles =\n      destination.droppableId === source.droppableId\n        ? scrambles\n        : destination.droppableId === 'round'\n        ? round.scrambleSets\n        : availableScrambles;\n\n    // Insert the scramble to the new array at the correct spot\n    destScrambles.splice(destination.index, 0, scramble);\n\n    if (\n      destination.droppableId === 'available' &&\n      source.droppableId === 'available'\n    )\n      this.setState({ availableScrambles: destScrambles });\n    else if (destination.droppableId === 'round')\n      attachScramblesToRound(destScrambles, round);\n    else attachScramblesToRound(scrambles, round);\n  };\n\n  handleAttemptBasedMove = (source, destination) => {\n    const { round, attachScramblesToRound } = this.props;\n    const { availableScrambles } = this.state;\n    // Again we just need to update the parent state\n    let scrambles = round.scrambleSets;\n    // Group round's scrambles based on attempt number\n    let scramblesByAttempt = groupBy(scrambles, s => s.attemptNumber);\n    let scramble = null;\n    scramble =\n      source.droppableId === 'available'\n        ? availableScrambles[source.index]\n        : scramblesByAttempt[attemptFromDroppable(source)].splice(\n            source.index,\n            1\n          )[0];\n\n    if (destination.droppableId !== 'available') {\n      let destAttempt = attemptFromDroppable(destination);\n      // update the attempt number\n      scramble.attemptNumber = destAttempt;\n      // if that's the first scramble we move there, the entry won't exist yet\n      scramblesByAttempt[destAttempt] = scramblesByAttempt[destAttempt] || [];\n      // actually move the scramble to the appropriate list\n      scramblesByAttempt[destAttempt].splice(destination.index, 0, scramble);\n    }\n\n    // Concatenate everything for the update\n    scrambles = flatMap(\n      Object.keys(scramblesByAttempt),\n      k => scramblesByAttempt[k]\n    );\n    attachScramblesToRound(scrambles, round);\n  };\n\n  handleScrambleMovement = result => {\n    const { source, destination } = result;\n\n    // dropped outside the list\n    if (!destination) {\n      return;\n    }\n\n    if (\n      source.droppableId.includes('-') ||\n      destination.droppableId.includes('-')\n    )\n      this.handleAttemptBasedMove(source, destination);\n    else this.handleGenericMove(source, destination);\n  };\n\n  render() {\n    const { event, round } = this.props;\n    const { availableScrambles } = this.state;\n    return (\n      <DragDropContext onDragEnd={this.handleScrambleMovement}>\n        <Typography variant=\"h3\" align=\"center\">\n          {roundName(event.rounds.length, round)}\n        </Typography>\n        <Grid container justify=\"center\">\n          <Grid item xs={6} style={{ padding: 16 }} align=\"center\">\n            {['333mbf', '333fm'].includes(event.id) ? (\n              <ListForAttemptBasedRound round={round} />\n            ) : (\n              <ListForGenericRound round={round} />\n            )}\n          </Grid>\n          <Grid item xs={6} style={{ padding: 16 }} align=\"center\">\n            <Paper>\n              <Typography variant=\"h4\">Available</Typography>\n              <ScrambleList\n                scrambles={availableScrambles}\n                holds=\"available\"\n                round={round}\n              />\n            </Paper>\n          </Grid>\n        </Grid>\n      </DragDropContext>\n    );\n  }\n}\n","import React from 'react';\nimport Paper from '@material-ui/core/Paper';\nimport Button from '@material-ui/core/Button';\nimport ButtonGroup from '@material-ui/core/ButtonGroup';\nimport Link from '@material-ui/core/Link';\nimport Typography from '@material-ui/core/Typography';\nimport TextField from '@material-ui/core/TextField';\n\nimport { competitionLink } from '../../../logic/wcif';\n\nconst LinkToNewPage = props => {\n  const { block, ...extraProps } = props;\n  return (\n    <Link {...extraProps} target=\"_blank\" rel=\"noreferrer\">\n      {block}\n    </Link>\n  );\n};\n\nconst HelperWithLink = ({ id }) => (\n  <span>\n    The ID is correct if and only if{' '}\n    <LinkToNewPage href={`${competitionLink(id)}`} block=\"this link\" /> opens\n    your competition's page.\n  </span>\n);\n\nconst CompetitionDetailsPanel = props => {\n  const {\n    wcif,\n    downloadWcifAction,\n    downloadResultsJsonAction,\n    classes,\n    uploadCompetitionIdAction,\n  } = props;\n\n  const exportAvailable = wcif.id;\n  // For now allow export even if missing scrambles.\n  // && competitionHasValidScrambles(wcif);\n\n  const handleNameChange = ev => uploadCompetitionIdAction(ev.target.value);\n  return (\n    <Paper className={classes.paper}>\n      <Typography variant=\"h4\" className={classes.h}>\n        Competition details\n      </Typography>\n      <form className={classes.mb3} noValidate autoComplete=\"off\">\n        <TextField\n          id=\"outlined-name\"\n          label=\"Competition ID\"\n          //className={classes.textField}\n          value={wcif.id || ''}\n          onChange={handleNameChange}\n          helperText={<HelperWithLink id={wcif.id} />}\n          margin=\"normal\"\n          variant=\"outlined\"\n        />\n      </form>\n      <Typography paragraph>\n        When you have made sure your competition ID is correct and all your\n        rounds have the correct scrambles, you can get the export you want\n        below.\n      </Typography>\n      <ButtonGroup\n        variant=\"contained\"\n        color=\"primary\"\n        aria-label=\"outlined primary button group\"\n        disabled={!exportAvailable}\n      >\n        <Button onClick={downloadWcifAction}>Get WCIF</Button>\n        <Button onClick={downloadResultsJsonAction}>Get results JSON</Button>\n      </ButtonGroup>\n    </Paper>\n  );\n};\n\nexport default CompetitionDetailsPanel;\n","import React from 'react';\nimport Paper from '@material-ui/core/Paper';\nimport Button from '@material-ui/core/Button';\nimport Grid from '@material-ui/core/Grid';\nimport Typography from '@material-ui/core/Typography';\nimport FreeBreakfastIcon from '@material-ui/icons/FreeBreakfast';\nimport DeleteIcon from '@material-ui/icons/Delete';\nimport classnames from 'classnames';\nimport { green } from '@material-ui/core/colors';\nimport { withStyles } from '@material-ui/core/styles';\n\nconst GreenButton = withStyles(theme => ({\n  root: {\n    color: theme.palette.getContrastText(green[500]),\n    backgroundColor: green[500],\n    '&:hover': {\n      backgroundColor: green[700],\n    },\n  },\n}))(Button);\n\nconst MatchingScramblesPanel = ({\n  assignAction,\n  clearAction,\n  uploadAction,\n  classes,\n}) => {\n  return (\n    <Paper className={classes.paper}>\n      <Typography variant=\"h4\" className={classes.h}>\n        Matching scrambles to rounds\n      </Typography>\n      <Typography paragraph align=\"justify\">\n        Clicking \"Automatically assign scrambles\" will attempt to automatically\n        detect which scrambles sets belongs to which round. Unlike the workbook\n        assistant, this will attempt to assign unused scrambles only to rounds{' '}\n        <b>without</b> scrambles! Which means that clicking several times the\n        button with the same uploaded scrambles will have no effect.\n        <br />\n        You can check scrambles assignments by browsing through the rounds in\n        the menu. For each round (or each attempt for Multiple Blindfolded and\n        Fewest Moves) you can assign scrambles manually from the unused\n        scrambles in the uploaded scrambles.\n        <br />\n        When everything looks good, get the Results JSON to import the results\n        on the WCA website.\n        <br />\n        Don't forget to set the competition ID if it's not detected!\n      </Typography>\n      <Grid container direction=\"row\">\n        <Grid item xs={12}>\n          <input\n            accept=\".json\"\n            className={classes.input}\n            id=\"add-scramble-json\"\n            multiple\n            type=\"file\"\n            onChange={uploadAction}\n          />\n          <label htmlFor=\"add-scramble-json\">\n            <GreenButton\n              variant=\"contained\"\n              component=\"span\"\n              color=\"primary\"\n              className={classnames(classes.addJsonButton, classes.mb3)}\n            >\n              Upload scrambles json\n            </GreenButton>\n          </label>\n        </Grid>\n        <Grid item xs={6} style={{ paddingRight: 8 }}>\n          <Button\n            variant=\"contained\"\n            component=\"span\"\n            color=\"primary\"\n            fullWidth\n            className={classes.button}\n            onClick={assignAction}\n          >\n            <FreeBreakfastIcon className={classes.extendedIcon} />\n            Automatically assign scrambles\n          </Button>\n        </Grid>\n        <Grid item xs={6} style={{ paddingLeft: 8 }}>\n          <Button\n            variant=\"contained\"\n            color=\"secondary\"\n            fullWidth\n            className={classes.button}\n            onClick={clearAction}\n          >\n            <DeleteIcon className={classes.extendedIcon} />\n            Clear scrambles assignments\n          </Button>\n        </Grid>\n      </Grid>\n    </Paper>\n  );\n};\n\nexport default MatchingScramblesPanel;\n","import React, { useState, Fragment } from 'react';\nimport { withStyles, makeStyles } from '@material-ui/core/styles';\nimport Card from '@material-ui/core/Card';\nimport Link from '@material-ui/core/Link';\nimport CardHeader from '@material-ui/core/CardHeader';\nimport CardContent from '@material-ui/core/CardContent';\nimport IconButton from '@material-ui/core/IconButton';\nimport List from '@material-ui/core/List';\nimport ListItem from '@material-ui/core/ListItem';\nimport ExpandMoreIcon from '@material-ui/icons/ExpandMore';\nimport Typography from '@material-ui/core/Typography';\nimport Collapse from '@material-ui/core/Collapse';\nimport clsx from 'clsx';\n\nconst useStyles = makeStyles(theme => ({\n  expand: {\n    transform: 'rotate(0deg)',\n    transition: theme.transitions.create('transform', {\n      duration: theme.transitions.duration.shortest,\n    }),\n  },\n  expandOpen: {\n    transform: 'rotate(180deg)',\n  },\n  card: {\n    marginBottom: theme.spacing(2),\n  },\n}));\n\nconst NestedScrambleItem = withStyles(theme => ({\n  root: {\n    paddingLeft: theme.spacing(4),\n  },\n}))(ListItem);\n\nconst ScrambleFileInfo = ({ scramble }) => {\n  const classes = useStyles();\n  const [expanded, setExpanded] = useState(false);\n\n  function handleExpandClick() {\n    setExpanded(!expanded);\n  }\n\n  return (\n    <Card className={classes.card}>\n      <CardHeader\n        action={\n          <IconButton\n            className={clsx(classes.expand, {\n              [classes.expandOpen]: expanded,\n            })}\n            onClick={handleExpandClick}\n            aria-expanded={expanded}\n            aria-label=\"show more\"\n          >\n            <ExpandMoreIcon />\n          </IconButton>\n        }\n        title={\n          <Link\n            component=\"button\"\n            variant=\"h5\"\n            color=\"inherit\"\n            onClick={handleExpandClick}\n          >\n            {scramble.competitionName}\n          </Link>\n        }\n        subheader={\n          <Fragment>\n            <Typography variant=\"body2\" component=\"p\" color=\"textSecondary\">\n              Generated with {scramble.version}\n            </Typography>\n            <Typography variant=\"body2\" component=\"p\" color=\"textSecondary\">\n              On {scramble.generationDate}\n            </Typography>\n          </Fragment>\n        }\n      />\n      <Collapse in={expanded} timeout=\"auto\" unmountOnExit>\n        <CardContent>\n          <List dense>\n            {scramble.sheets.map(sheet => (\n              <NestedScrambleItem key={sheet.id}>\n                {sheet.title}\n              </NestedScrambleItem>\n            ))}\n          </List>\n        </CardContent>\n      </Collapse>\n    </Card>\n  );\n};\n\nexport default ScrambleFileInfo;\n","import React from 'react';\nimport Paper from '@material-ui/core/Paper';\nimport Typography from '@material-ui/core/Typography';\nimport ScrambleFileInfo from '../../Scrambles/ScrambleFileInfo';\n\nconst UploadedScramblesPanel = ({ uploadedScrambles, classes }) => {\n  return (\n    <Paper className={classes.paper}>\n      <Typography variant=\"h4\" className={classes.h}>\n        Uploaded JSON files: {uploadedScrambles.length}\n      </Typography>\n      {uploadedScrambles.map(s => (\n        <ScrambleFileInfo scramble={s} key={s.competitionName} />\n      ))}\n    </Paper>\n  );\n};\n\nexport default UploadedScramblesPanel;\n","import React, { Fragment } from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport {\n  internalWcifToWcif,\n  internalWcifToResultsJson,\n} from '../../../logic/import-export-wcif';\nimport { autoAssignScrambles, clearScrambles } from '../../../logic/scrambles';\nimport CompetitionDetailsPanel from './CompetitionDetailsPanel';\nimport MatchingScramblesPanel from './MatchingScramblesPanel';\nimport UploadedScramblesPanel from './UploadedScramblesPanel';\n\nconst downloadFile = (wcif, exporter, filename = 'wcif.json') => {\n  let blob = new Blob([JSON.stringify(exporter(wcif))], {\n    type: 'application/json',\n  });\n  let blobURL = window.URL.createObjectURL(blob);\n\n  let tmp = document.createElement('a');\n  tmp.href = blobURL;\n  tmp.setAttribute('download', filename);\n  document.body.appendChild(tmp);\n  tmp.click();\n};\n\nconst useStyles = makeStyles(theme => ({\n  input: {\n    display: 'none',\n  },\n  addJsonButton: {\n    width: '100%',\n    marginTop: theme.spacing(2),\n  },\n  extendedIcon: {\n    marginRight: theme.spacing(1),\n  },\n  mb3: {\n    marginBottom: theme.spacing(3),\n  },\n  button: {\n    marginRight: theme.spacing(3),\n  },\n  paper: {\n    padding: 16,\n    marginBottom: theme.spacing(2),\n  },\n  h: {\n    marginBottom: theme.spacing(1),\n  },\n}));\n\nconst CompetitionInfo = ({\n  wcif,\n  uploadedScrambles,\n  uploadAction,\n  handleWcifChange,\n  version,\n}) => {\n  const classes = useStyles();\n\n  const actionDownloadWcif = () =>\n    downloadFile(wcif, internalWcifToWcif, `WCIF for ${wcif.name}.json`);\n\n  const actionDownloadResultsJson = () =>\n    downloadFile(\n      wcif,\n      wcif => internalWcifToResultsJson(wcif, version),\n      `Results for ${wcif.name}.json`\n    );\n\n  const actionAssignScrambles = () =>\n    handleWcifChange(autoAssignScrambles(wcif, uploadedScrambles));\n\n  const actionClearScrambles = () => handleWcifChange(clearScrambles(wcif));\n\n  const uploadCompetitionIdAction = id => handleWcifChange({ ...wcif, id: id });\n\n  return (\n    <Fragment>\n      <CompetitionDetailsPanel\n        downloadWcifAction={actionDownloadWcif}\n        downloadResultsJsonAction={actionDownloadResultsJson}\n        uploadCompetitionIdAction={uploadCompetitionIdAction}\n        classes={classes}\n        wcif={wcif}\n      />\n      <MatchingScramblesPanel\n        assignAction={actionAssignScrambles}\n        uploadAction={uploadAction}\n        clearAction={actionClearScrambles}\n        classes={classes}\n      />\n      <UploadedScramblesPanel\n        uploadedScrambles={uploadedScrambles}\n        classes={classes}\n      />\n    </Fragment>\n  );\n};\n\nexport default CompetitionInfo;\n","import React, { Component } from 'react';\n\nimport Typography from '@material-ui/core/Typography';\nimport Grid from '@material-ui/core/Grid';\nimport CompetitionMenu from './CompetitionMenu/CompetitionMenu';\nimport RoundPanel from './RoundPanel/RoundPanel';\nimport CompetitionInfo from './CompetitionInfo/CompetitionInfo';\nimport { flatMap, updateIn } from '../../logic/utils';\nimport { parseActivityCode } from '../../logic/wcif';\nimport { getUniqueScrambleUploadedId } from '../../logic/import-export-wcif';\nimport {\n  updateMultiAndFm,\n  transformUploadedScrambles,\n  allScramblesForEvent,\n  usedScramblesIdsForEvent,\n} from '../../logic/scrambles';\n\nimport { version } from '../../../package.json';\n\nexport default class Competition extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      wcif: props.wcif,\n      selectedRoundId: null,\n      uploadedScrambles: props.uploadedScrambles,\n    };\n  }\n\n  componentDidMount() {\n    window.addEventListener('beforeunload', this.handleOnBeforeUnload);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('beforeunload', this.handleOnBeforeUnload);\n  }\n\n  handleOnBeforeUnload = ev => {\n    ev.preventDefault();\n    ev.returnValue = '';\n  };\n\n  // It's worth noting we only handle one competition over the life of the component,\n  // therefore no componentDidUpdate is necessary.\n  // To upload scrambles for another competition the user would just refresh the page.\n\n  uploadNewScramble = ev => {\n    let reader = new FileReader();\n\n    reader.onload = e => {\n      // TODO: some check we're facing well formatted scrambles\n      this.setState(state => {\n        let newScramble = JSON.parse(e.target.result);\n        // Manually assign some id, in case someone uses same name for zip\n        // but with different scrambles.\n        newScramble.competitionName = `${getUniqueScrambleUploadedId()}: ${\n          newScramble.competitionName\n        }`;\n        newScramble = updateIn(newScramble, ['sheets'], updateMultiAndFm);\n        newScramble = transformUploadedScrambles(newScramble);\n        return {\n          wcif: {\n            ...state.wcif,\n            scrambleProgram: newScramble.version,\n          },\n          uploadedScrambles: [...state.uploadedScrambles, newScramble],\n        };\n      });\n    };\n\n    reader.onerror = e => {\n      alert(\"Couldn't load the JSON scrambles file\");\n    };\n\n    if (ev.target.files.length > 0) reader.readAsText(ev.target.files[0]);\n  };\n\n  attachScramblesToRound = (scrambles, round) => {\n    const { wcif } = this.state;\n    let { eventId } = parseActivityCode(round.id);\n    let eventIndex,\n      roundIndex = null;\n    let event = wcif.events.find((e, index) => {\n      eventIndex = index;\n      return e.id === eventId;\n    });\n    event.rounds.find((r, index) => {\n      roundIndex = index;\n      return r.id === round.id;\n    });\n    this.setState({\n      wcif: updateIn(wcif, ['events', eventIndex, 'rounds', roundIndex], r => ({\n        ...r,\n        scrambleSets: scrambles,\n      })),\n    });\n  };\n\n  handleWcifChange = wcif => this.setState({ wcif });\n\n  setSelectedRound = id => this.setState({ selectedRoundId: id });\n\n  render() {\n    const { wcif, selectedRoundId, uploadedScrambles } = this.state;\n    // const { handleWcifUpdate } = this.props;\n    const rounds = flatMap(wcif.events, e => e.rounds);\n    let availableScrambles = [];\n    let round = null;\n    let event = null;\n    if (selectedRoundId) {\n      round = rounds.find(r => r.id === selectedRoundId);\n      let { eventId } = parseActivityCode(round.id);\n      event = wcif.events.find(e => e.id === eventId);\n      let used = usedScramblesIdsForEvent(wcif.events, event.id);\n      availableScrambles = allScramblesForEvent(\n        uploadedScrambles,\n        event.id,\n        used\n      );\n    }\n    return (\n      <Grid container>\n        <Grid item xs={12} style={{ padding: 16 }}>\n          <Typography variant=\"h2\" component=\"h1\" align=\"center\">\n            {wcif.name}\n          </Typography>\n        </Grid>\n        <Grid item xs={12} md={3} lg={2} style={{ padding: 16 }}>\n          <CompetitionMenu\n            events={wcif.events}\n            setSelectedRound={this.setSelectedRound}\n          />\n        </Grid>\n        <Grid item xs={12} md={9} style={{ padding: 16 }}>\n          {round ? (\n            <RoundPanel\n              event={event}\n              round={round}\n              availableScrambles={availableScrambles}\n              attachScramblesToRound={this.attachScramblesToRound}\n            />\n          ) : (\n            <CompetitionInfo\n              wcif={wcif}\n              uploadedScrambles={uploadedScrambles}\n              uploadAction={this.uploadNewScramble}\n              handleWcifChange={this.handleWcifChange}\n              version={version}\n            />\n          )}\n        </Grid>\n      </Grid>\n    );\n  }\n}\n","import { sum } from './utils';\n\nexport const decodeMbldResult = value => {\n  if (value <= 0) return { solved: 0, attempted: 0, centiseconds: value };\n  const missed = value % 100;\n  const seconds = Math.floor(value / 100) % 1e5;\n  const difference = 99 - (Math.floor(value / 1e7) % 100);\n  const solved = difference + missed;\n  const attempted = solved + missed;\n  const centiseconds = seconds === 99999 ? null : seconds * 100;\n  return { solved, attempted, centiseconds };\n};\n\nexport const encodeMbldResult = ({ solved, attempted, centiseconds }) => {\n  if (centiseconds <= 0) return centiseconds;\n  const missed = attempted - solved;\n  const dd = 99 - (solved - missed);\n  const seconds = Math.round(\n    (centiseconds || 9999900) / 100\n  ); /* 99999 seconds is used for unknown time. */\n  return dd * 1e7 + seconds * 1e2 + missed;\n};\n\nconst timeInSecToValue = resultString =>\n  Math.round(parseFloat(resultString) * 100);\n\nconst timeInMinutesToValue = resultString => {\n  let [min, rest] = resultString.split(':');\n  min = parseInt(min);\n  const centisec = timeInSecToValue(rest);\n  return min * 6000 + centisec;\n};\n\nexport const meanFromAttempts = attempts => {\n  return attempts.some(a => a < 0)\n    ? -1\n    : Math.round(sum(attempts) / attempts.length);\n};\n\nexport const timeToValue = (resultString, asMove = false) => {\n  switch (resultString) {\n    case 'DNF':\n      return -1;\n    case 'DNS':\n      return -2;\n    default:\n      if (!resultString) {\n        return 0;\n      } else if (asMove) {\n        return parseInt(resultString);\n      } else if (resultString.includes(':')) {\n        return timeInMinutesToValue(resultString);\n      } else {\n        return timeInSecToValue(resultString);\n      }\n  }\n};\n","import { registrantIdFromAttributes } from './wcif';\nimport { timeToValue, meanFromAttempts } from './results';\nimport { roundTypeFromCellName } from './roundtypes';\n\nconst formatStringToId = {\n  'Format: best of 1': '1',\n  'Format: best of 2': '2',\n  'Format: best of 3': '3',\n  'Format: mean of 3': 'm',\n  'Format: average of 5': 'a',\n  'Format: average of 5 (removing best and worst)': 'a',\n};\n\nconst expectedNumberOfAttemptsByFormat = {\n  '1': 1,\n  '2': 2,\n  '3': 3,\n  m: 3,\n  a: 5,\n};\n\n// First two rows contain the competition name and irrelevant information.\n// Third row is these headers\n//[\"#\", \"Name\", \"Country\", \"WCA id\", \"Gender\", \"Date of birth\", ...]\nexport const personWcifFromRegistrationXlsx = sheet =>\n  sheet.splice(0, 3) &&\n  sheet.map(person => ({\n    registrantId: parseInt(person[0]),\n    name: person[1],\n    wcaUserId: null,\n    country: person[2],\n    wcaId: person[3] || null,\n    gender: person[4],\n    birthdate: person[5],\n    // We actually don't need to fill this to post results.\n    registration: {},\n    email: null,\n    avatar: null,\n    roles: [],\n    assignments: [],\n    personalBests: [],\n  }));\n\nconst attemptsFromResultRow = (eventId, formatId, row) => {\n  let maxAttempts = expectedNumberOfAttemptsByFormat[formatId];\n  if (eventId === '333mbf') {\n    return [...Array(maxAttempts).keys()].map(index => ({\n      // For MBF there is a 4 column offset for the person,\n      // then each result takes 4 columns.\n      result: parseInt(row[7 + index * 4]),\n    }));\n  } else {\n    let attempts = row\n      .slice(4, 4 + maxAttempts)\n      .filter(a => a)\n      .map(a => ({\n        result: timeToValue(a, eventId === '333fm'),\n      }));\n    // Fillup to expected number of attempts.\n    // Not necessary but useful to export to results JSON.\n    while (attempts.length !== maxAttempts) attempts.push({ result: 0 });\n    return attempts;\n  }\n};\n\nconst bestForRow = (eventId, formatId, row) => {\n  let maxAttempts = expectedNumberOfAttemptsByFormat[formatId];\n  if (formatId === '1') {\n    // Then there is no \"best\" column\n    return eventId === '333mbf'\n      ? parseInt(row[7])\n      : timeToValue(row[4], eventId === '333fm');\n  } else {\n    // Use extra offset for the \"best\" column\n    return eventId === '333mbf'\n      ? parseInt(row[4 + maxAttempts * 4])\n      : timeToValue(row[4 + maxAttempts], eventId === '333fm');\n  }\n};\n\nconst avgForRow = (eventId, formatId, row) => {\n  if (eventId === '333mbf') return 0;\n  // also get the average for the best of 3 format:\n  // the only events which can use it are 3bf, 4bf, 5bf, and 3mbf.\n  // Except for 3mbf, we recognize the average.\n  if (['3', 'm', 'a'].includes(formatId)) {\n    let maxAttempts = expectedNumberOfAttemptsByFormat[formatId];\n    if (formatId === 'a') {\n      // 5 would return the WR marker for the best.\n      // 6 would return the worst.\n      return timeToValue(row[7 + maxAttempts]);\n    } else {\n      // For FM mo3, the value doesn't need to be taken as moves!\n      // 5 would return the WR marker for the best.\n      let avgDetected = timeToValue(row[6 + maxAttempts]);\n      if (!avgDetected && eventId === '333bf') {\n        // Let's compute the mean\n        let attempts = attemptsFromResultRow(eventId, formatId, row);\n        if (attempts.length !== 3)\n          throw new Error(\n            `Can't compute mean, detected only ${attempts.length} attempts`\n          );\n        avgDetected = meanFromAttempts(attempts.map(a => a.result));\n      }\n      return avgDetected;\n    }\n  }\n\n  return 0;\n};\n\n// First row: round name\n// Second row: format name\n// Third row: time format\n// Fourth row:\n//   [\"Position\", \"Name\", \"Country\", \"WCA id\", \"1\", \"2\", \"3\", \"4\", \"5\", \"Best\", \"WR\", \"Worst\", \"Average\", \"WR\"]\n// or for multi:\n//   [\"Position\", \"Name\", \"Country\", \"WCA id\", \"tried\", \"solved\", \"seconds\", \"score 1\", \"WR\"]\nexport const roundWcifFromXlsx = (persons, eventId, roundNumber, sheet) => {\n  let roundFormat = formatStringToId[sheet[1][0]];\n  let roundType = roundTypeFromCellName(sheet[0][0]);\n  if (!roundFormat)\n    throw new Error(`Couldn't get format from string \"${sheet[1][0]}\"`);\n  if (!roundType)\n    throw new Error(`Couldn't get roundTypeId from string \"${sheet[0][0]}\"`);\n  sheet.splice(0, 4);\n  return {\n    advancementCondition: null,\n    id: `${eventId}-r${roundNumber}`,\n    roundTypeId: roundType.id,\n    cutoff: null,\n    format: roundFormat,\n    results: sheet\n      .filter(row => row[1])\n      .map(row => ({\n        ranking: parseInt(row[0]),\n        personId: registrantIdFromAttributes(\n          persons,\n          row[1],\n          row[2],\n          row[3] || null\n        ),\n        attempts: attemptsFromResultRow(eventId, roundFormat, row),\n        // these are *not* in the WCIF, but will make our life easier to export\n        // to results json!\n        best: bestForRow(eventId, roundFormat, row),\n        average: avgForRow(eventId, roundFormat, row),\n      })),\n    scrambleSetCount: 0,\n    scrambleSets: [],\n    timeLimit: null,\n  };\n};\n","import React from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport Button from '@material-ui/core/Button';\nimport Typography from '@material-ui/core/Typography';\nimport Paper from '@material-ui/core/Paper';\nimport Grid from '@material-ui/core/Grid';\nimport XLSX from 'xlsx';\nimport {\n  personWcifFromRegistrationXlsx,\n  roundWcifFromXlsx,\n} from '../../logic/xlsx-utils';\n\n//import tmpWcif from '../../wcifresults.json';\n\nconst useStyles = makeStyles(theme => ({\n  input: {\n    display: 'none',\n  },\n  h: {\n    marginBottom: theme.spacing(3),\n  },\n  button: {\n    marginLeft: theme.spacing(3),\n  },\n}));\n\nconst loadSheetIntoWcif = (wcif, name, jsonSheet) => {\n  // This function strongly assumes that 'Registration' is the first sheet...\n  if (name === 'Registration') {\n    wcif.name = jsonSheet[0][0];\n    wcif.shortName = wcif.name;\n    wcif.persons = personWcifFromRegistrationXlsx(jsonSheet);\n  } else {\n    // Cubecomps export numbers for round identification, CubingChina exports\n    // the roundTypeId.\n    let eventId = name.split('-')[0];\n    let event = wcif.events.find(e => e.id === eventId);\n    if (!event) {\n      event = {\n        id: eventId,\n        rounds: [],\n        competitorLimit: null,\n        qualification: null,\n      };\n      wcif.events.push(event);\n    }\n    let roundNumber = event.rounds.length + 1;\n    event.rounds.push(\n      roundWcifFromXlsx(wcif.persons, eventId, roundNumber, jsonSheet)\n    );\n  }\n};\n\nconst xlsxOptions = {\n  header: 1,\n  raw: false,\n  blankrows: false,\n};\n\nconst handleXlsxUploadChange = (updater, event) => {\n  const reader = new FileReader();\n  const rABS = !!reader.readAsBinaryString;\n\n  reader.onload = e => {\n    const wb = XLSX.read(e.target.result, { type: rABS ? 'binary' : 'array' });\n    const sheetNames = wb.SheetNames;\n    const wcif = {\n      // Unfortunately this is not included in the XLSX :(\n      id: null,\n      name: '<undefined>',\n      shortName: '<undefined>',\n      schedule: [],\n      events: [],\n      persons: [],\n    };\n    sheetNames.forEach(name =>\n      loadSheetIntoWcif(\n        wcif,\n        name,\n        XLSX.utils.sheet_to_json(wb.Sheets[name], xlsxOptions)\n      )\n    );\n    updater(wcif);\n  };\n\n  reader.onerror = e => alert(\"Couldn't load the JSON file\");\n\n  if (rABS) reader.readAsBinaryString(event.target.files[0]);\n  else reader.readAsArrayBuffer(event.target.files[0]);\n};\n\nconst handleFileUploadChange = (updater, event) => {\n  let reader = new FileReader();\n\n  reader.onload = e => updater(JSON.parse(e.target.result));\n\n  reader.onerror = e => alert(\"Couldn't load the JSON file\");\n\n  reader.readAsText(event.target.files[0]);\n};\n\nconst ImportWCIF = ({ handleWcifJSONLoad }) => {\n  const classes = useStyles();\n  // Dirty hack to preload given WCIF\n  //handleWcifJSONLoad(tmpWcif);\n  return (\n    <Grid container justify=\"center\">\n      <Grid item xs={12} md={8} lg={6} xl={6} style={{ padding: 16 }}>\n        <Paper style={{ padding: 16 }}>\n          <Typography\n            variant=\"h2\"\n            component=\"h1\"\n            align=\"center\"\n            className={classes.h}\n          >\n            Scrambles Matcher\n          </Typography>\n          <Typography paragraph>\n            This tool enables you to assign sets of JSON scrambles generated by\n            TNoodle to a WCIF. You can either import an existing WCIF or import\n            a results spreadsheet (created by cubecomps) that will be converted\n            to a WCIF.\n          </Typography>\n          <Typography color=\"error\" style={{ fontWeight: 'bold' }}>\n            There is currently no check whatsoever on the imported data.\n            <br />\n            If you upload incomplete results, or the wrong file on the wrong\n            place, the application will simply crash.\n            <br />\n            If you refresh the page, you will have to start over.\n          </Typography>\n          <Grid container direction=\"row\" justify=\"center\">\n            <Typography variant=\"h6\" className={classes.h}>\n              Get started:\n            </Typography>\n            <input\n              accept=\".json\"\n              className={classes.input}\n              id=\"raised-button-file\"\n              multiple\n              type=\"file\"\n              onChange={ev => handleFileUploadChange(handleWcifJSONLoad, ev)}\n            />\n            <label htmlFor=\"raised-button-file\">\n              <Button\n                component=\"span\"\n                variant=\"contained\"\n                color=\"primary\"\n                className={classes.button}\n              >\n                Upload WCIF\n              </Button>\n            </label>\n            <input\n              accept=\".xlsx\"\n              className={classes.input}\n              id=\"raised-button-xlsx\"\n              multiple\n              type=\"file\"\n              onChange={ev => handleXlsxUploadChange(handleWcifJSONLoad, ev)}\n            />\n            <label htmlFor=\"raised-button-xlsx\">\n              <Button\n                component=\"span\"\n                variant=\"contained\"\n                color=\"primary\"\n                className={classes.button}\n              >\n                Upload XLSX\n              </Button>\n            </label>\n          </Grid>\n          <Typography paragraph>\n            You are most likely used to using the Workbook Assistant (WA). For\n            competition where everything went well and you just have one single\n            and comprehensive JSON scrambles file, then using this should be\n            almost like using the WA.\n            <br />\n            If you have had to edit manually some scrambles JSON because of\n            Multiple Blindfolded, or if you have had to combine multiple\n            scrambles JSONs, read on! Here is a non exhaustive list of\n            differences:\n          </Typography>\n          <Typography variant=\"h6\">Additions</Typography>\n          <ul>\n            <li>\n              \"Better\" scrambles matching.\n              <br />\n              The WA re-assigns automatically scrambles each time you upload a\n              separate scrambles JSON. Even if you already matched a round to\n              its corresponding set in the already uploaded scrambles. Scrambles\n              Matcher assigns on-demand, and will only try to associate rounds\n              which have no scrambles to scrambles from the uploaded JSON(s).\n            </li>\n            <li>\n              Better Drag and Drop for scrambles.\n              <br />\n              If you have moved scrambles around in the WA you know what I'm\n              talking about.\n            </li>\n            <li>\n              Native support for attempt-based event.\n              <br />\n              Namely Multiple Blindfolded and Fewest Moves. When importing\n              scrambles JSON(s) it will split scramble sheets for these events\n              into attempt, so that they can be matched (manually or\n              automatically) to the attempt they have actually been used for.\n              <br />\n              Especially useful if you had to generate a couple of extra\n              scrambles for Multiple Blindfolded, or simply if you used several\n              groups for that event.\n              <br />\n              Then for the results JSON they are grouped together in a\n              meaningful way for the WCA website.\n            </li>\n            <li>\n              No more 100MB database download, no more java, just a html page to\n              load. However this leads to a missing feature (for now), see\n              below.\n            </li>\n          </ul>\n          <Typography variant=\"h6\">Missing feature</Typography>\n          <ul>\n            <li>\n              No more newcomers check. It does mean you will have to upload the\n              results to the WCA website first, as it will validate the list of\n              competitors. Since you can download the Results JSON even if you\n              don't have assigned scrambles, you should be able to check\n              newcomers even before going through scrambles assignment.\n            </li>\n          </ul>\n        </Paper>\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default ImportWCIF;\n","import React, { Component } from 'react';\nimport CssBaseline from '@material-ui/core/CssBaseline';\nimport Competition from '../Competition/Competition';\nimport ImportWCIF from '../ImportWCIF/ImportWCIF';\nimport { importWcif } from '../../logic/import-export-wcif';\n\nexport default class App extends Component {\n  state = {\n    wcif: null,\n    uploadedScrambles: [],\n    errors: [],\n  };\n\n  handleWcifJSONLoad = json => {\n    const [wcif, extractedScrambles] = importWcif(json);\n    this.setState({ wcif, uploadedScrambles: extractedScrambles });\n  };\n\n  handleWcifUpdate = wcif => {\n    this.setState({ wcif });\n  };\n\n  render() {\n    const { wcif, uploadedScrambles, errors } = this.state;\n    return (\n      <div\n        style={{ display: 'flex', minHeight: '100vh', flexDirection: 'column' }}\n      >\n        <CssBaseline />\n        {wcif ? (\n          <Competition\n            handleWcifUpdate={this.handleWcifUpdate}\n            wcif={wcif}\n            uploadedScrambles={uploadedScrambles}\n          />\n        ) : (\n          <ImportWCIF\n            handleWcifJSONLoad={this.handleWcifJSONLoad}\n            errors={errors}\n          />\n        )}\n      </div>\n    );\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'typeface-roboto';\nimport './wca_data/cubing-icons.css';\n\nimport App from './components/App/App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}