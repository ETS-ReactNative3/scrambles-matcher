{"version":3,"sources":["components/CubingIcon/CubingIcon.jsx","logic/utils.js","logic/formats.js","logic/scrambles.js","logic/countries.js","logic/roundtypes.js","logic/events.js","logic/wcif.js","components/Competition/CompetitionMenu/CompetitionMenu.jsx","components/Scrambles/ScrambleList.jsx","components/Competition/RoundPanel/RoundPanel.jsx","components/Competition/CompetitionInfo/CompetitionDetailsPanel.jsx","components/Competition/CompetitionInfo/MatchingScramblesPanel.jsx","components/Scrambles/ScrambleFileInfo.jsx","components/Competition/CompetitionInfo/UploadedScramblesPanel.jsx","components/Competition/CompetitionInfo/CompetitionInfo.jsx","components/Competition/Competition.jsx","logic/results.js","logic/xlsx-utils.js","components/ImportWCIF/ImportWCIF.jsx","components/App/App.jsx","index.js"],"names":["CubingIcon","_ref","eventId","props","Object","objectWithoutProperties","react_default","a","createElement","assign","style","fontSize","className","concat","updateArrayInplace","arr","index","newElem","updateIn","object","updater","_ref2","toArray","property","properyChain","slice","length","Number","isInteger","objectSpread","defineProperty","flatMap","fn","reduce","xs","x","groupBy","obj","sortCompare","y","sortBy","sort","formats","id","name","shortName","solveCount","cutoffFormats","formatById","find","format","uniqueScrambleSetId","addScrambleSetsIfMissing","rounds","map","r","scrambleSets","scrambleSetsForRound","usedScramblesId","round","uploadedScrambles","_idsFromRound","idsFromRound","_idsFromRound2","slicedToArray","roundNumber","firstMatchingSheets","up","sheets","filter","s","includes","numberOfAttempts","generatedAttemptNumber","attemptNumber","usedScramblesIdsForEvent","events","e","updateMultiAndFm","scrambles","event","scramble","sequence","title","scrambleSetId","splitMultiFm","ensureScramblesMember","transformUploadedScrambles","uploadedJson","filename","sheet","extraScrambles","sheetName","tnoodleSheetsToInternal","competitionName","prefixForIndex","String","fromCharCode","internalScramblesToWcifScrambles","scramblesByAttempt","keys","forEach","number","push","join","set","countries","wca_states","states_lists","list","states","roundTypes","rank","cellName","isFinal","roundTypeById","t","eventNameById","propertyById","sortWcifEvents","wcifEvents","wcifEvent","findIndex","roundTypeIdForRound","numberOfRounds","roundTypeId","cutoff","eventIdFromRound","split","_round$id$split","_round$id$split2","parseInt","registrantIdFromAttributes","persons","country","wcaId","p","registrantId","internalWcifToWcif","wcif","competitionLink","eventHasValidScrambles","every","roundHasValidScrambles","EventListItem","withStyles","root","color","& .cubing-icon, & svg","ListItem","useStyles","makeStyles","theme","item","paddingLeft","spacing","svg","& svg","CompetitionMenu","setSelectedRound","_useState","useState","_useState2","selectedEvent","setSelectedEvent","classes","List","dense","button","onClick","ListItemIcon","Info_default","ListItemText","primary","react","key","stopPropagation","components_CubingIcon_CubingIcon","Tooltip","ReportProblem_default","Collapse","in","timeout","unmountOnExit","classnames","DNDList","styled","minHeight","DraggableScramble","showPrefix","react_beautiful_dnd_esm","draggableId","provided","snapshot","ref","innerRef","draggableProps","dragHandleProps","isDragging","draggableStyle","background","secondary","ScrambleList","holds","droppableId","droppableProps","ScrambleList_DraggableScramble","placeholder","SpacedPaper","marginBottom","Paper","attemptFromDroppable","elem","ListForGenericRound","Typography","variant","Scrambles_ScrambleList","ListForAttemptBasedRound","nAttempts","attempts","toConsumableArray","Array","i","RoundPanel","_this","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","handleGenericMove","source","destination","_this$props","attachScramblesToRound","availableScrambles","state","splice","destScrambles","setState","handleAttemptBasedMove","_this$props2","destAttempt","k","handleScrambleMovement","result","prevProps","prevIds","_this$props3","onDragEnd","align","_idsFromRound3","roundName","Grid","container","justify","md","padding","RoundPanel_ListForAttemptBasedRound","RoundPanel_ListForGenericRound","Component","LinkToNewPage","block","extraProps","Link","target","rel","HelperWithLink","CompetitionDetailsPanel_LinkToNewPage","href","CompetitionDetailsPanel","downloadWcifAction","downloadResultsJsonAction","uploadCompetitionIdAction","exportAvailable","paper","h","mb3","noValidate","autoComplete","TextField","label","value","onChange","ev","helperText","CompetitionDetailsPanel_HelperWithLink","margin","paragraph","ButtonGroup","aria-label","disabled","Button","GreenButton","palette","getContrastText","green","backgroundColor","&:hover","MatchingScramblesPanel","assignAction","clearAction","uploadAction","direction","accept","input","multiple","type","htmlFor","component","addJsonButton","paddingRight","fullWidth","FreeBreakfast_default","extendedIcon","Delete_default","expand","transform","transition","transitions","create","duration","shortest","expandOpen","card","NestedScrambleItem","ScrambleFileInfo","expanded","setExpanded","handleExpandClick","Card","CardHeader","action","IconButton","clsx","aria-expanded","ExpandMore_default","subheader","version","generationDate","CardContent","UploadedScramblesPanel","Scrambles_ScrambleFileInfo","downloadFile","exporter","arguments","undefined","blob","Blob","JSON","stringify","blobURL","window","URL","createObjectURL","tmp","document","setAttribute","body","appendChild","click","display","width","marginTop","marginRight","CompetitionInfo","handleWcifChange","CompetitionInfo_CompetitionDetailsPanel","formatVersion","competitionId","countryId","iso2","gender","dob","birthdate","roundId","formatId","results","res","personId","position","ranking","best","average","groups","group","scrambleProgram","resultsProgram","internalWcifToResultsJson","CompetitionInfo_MatchingScramblesPanel","usedScrambleIdsByEvent","autoAssignScrambles","clearScrambles","CompetitionInfo_UploadedScramblesPanel","scrambleUploadedId","Competition","handleOnBeforeUnload","preventDefault","returnValue","uploadNewScramble","reader","FileReader","onload","newScramble","parse","onerror","alert","files","readAsText","eventIndex","roundIndex","selectedRoundId","addEventListener","removeEventListener","_this$state","used","usedIds","allScramblesForEvent","lg","xl","Competition_CompetitionMenu_CompetitionMenu","RoundPanel_RoundPanel","Competition_CompetitionInfo_CompetitionInfo","timeInSecToValue","resultString","Math","parseFloat","timeToValue","asMove","_resultString$split","_resultString$split2","min","rest","timeInMinutesToValue","formatStringToId","Format: best of 1","Format: best of 2","Format: best of 3","Format: mean of 3","Format: average of 5","Format: average of 5 (removing best and worst)","expectedNumberOfAttemptsByFormat","1","2","3","m","attemptsFromResultRow","row","maxAttempts","bestForRow","avgForRow","roundWcifFromXlsx","roundFormat","roundType","Error","advancementCondition","scrambleSetCount","timeLimit","marginLeft","loadSheetIntoWcif","jsonSheet","person","wcaUserId","registration","email","avatar","roles","assignments","personalBests","competitorLimit","qualification","xlsxOptions","header","raw","blankrows","ImportWCIF","handleWcifJSONLoad","fontWeight","handleFileUploadChange","rABS","readAsBinaryString","wb","XLSX","read","sheetNames","SheetNames","schedule","utils","sheet_to_json","Sheets","readAsArrayBuffer","handleXlsxUploadChange","App","errors","json","handleWcifUpdate","flexDirection","CssBaseline","Competition_Competition","components_ImportWCIF_ImportWCIF","ReactDOM","render","App_App","getElementById"],"mappings":"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","file":"static/js/main.7a7b295b.chunk.js","sourcesContent":["import React from 'react';\n\nconst CubingIcon = ({ eventId, ...props }) => (\n  <span\n    style={{ fontSize: 24 }}\n    className={`cubing-icon event-${eventId}`}\n    {...props}\n  />\n);\n\nexport default CubingIcon;\n","\nconst updateArrayInplace = (arr, index, newElem) => {\n  arr[index] = newElem;\n  return arr;\n}\n\n/**\n * Returns a copy of the object with the value at the specified path transformed by the update function.\n *\n * @param {Object} object\n * @param {Array} propertyChain\n * @param {Function} updater\n * @returns {Object}\n */\nexport const updateIn = (object, [property, ...properyChain], updater) =>\n  properyChain.length === 0\n    ?\n      Number.isInteger(property) ? updateArrayInplace(object, property, updater(object[property]))\n      : { ...object, [property]: updater(object[property]) }\n    :\n      Number.isInteger(property) ? updateArrayInplace(object, property, updateIn(object[property], properyChain, updater))\n      : { ...object, [property]: updateIn(object[property], properyChain, updater) };\n\n/**\n * Returns a copy of the object with the value at the specified path set to the given one.\n *\n * @param {Object} object\n * @param {Array} propertyChain\n * @param {*} value\n * @returns {Object}\n */\nexport const setIn = (object, properyChain, value) =>\n  updateIn(object, properyChain, () => value);\n\n/**\n * Returns a copy of the object with the value at the specified path merged with the given one.\n *\n * @param {Object} object\n * @param {Array} propertyChain\n * @param {Object} newValue\n * @returns {Object}\n */\nexport const mergeIn = (object, properyChain, newValue) =>\n  updateIn(object, properyChain, currentValue => ({ ...currentValue, ...newValue }));\n\n/**\n * Returns a copy of the object with the array at the specified path mapped with the given function.\n *\n * @param {Object} object\n * @param {Array} propertyChain\n * @param {Object} mapper\n * @returns {Object}\n */\nexport const mapIn = (object, properyChain, mapper) =>\n  updateIn(object, properyChain, array => array && array.map(mapper));\n\n/**\n * Returns object's value at the specified path or the default value if it doesn't exist.\n *\n * @param {Object} object\n * @param {Array} propertyChain\n * @param {*} defaultValue\n * @returns {*}\n */\nexport const getIn = (object, [property, ...propertyChain], defaultValue = null) =>\n  object ? (\n    propertyChain.length === 0\n      ? (object.hasOwnProperty(property) ? object[property] : defaultValue)\n      : getIn(object[property], propertyChain, defaultValue)\n  ) : defaultValue;\n\n/**\n * Checks if the given value is an object.\n *\n * @param {*} value\n * @returns {boolean}\n */\nconst isObject = obj => obj === Object(obj);\n\n/**\n * When given an object, deeply checks if it doesn't contain null values.\n * Otherwise, checks if the given value is not null.\n *\n * @param {*} value\n * @returns {boolean}\n */\nexport const isPresentDeep = value =>\n  isObject(value)\n    ? Object.values(value).every(isPresentDeep)\n    : value != null;\n\n/**\n * Pluralizes a word according to the given number.\n * When no plural form given, uses singular form with an 's' appended.\n *\n * @param {number} count\n * @param {string} singular\n * @param {string} plural\n * @returns {string}\n */\nexport const pluralize = (count, singular, plural) =>\n  `${count} ${count === 1 ? singular : (plural || singular + 's')}`\n\n/**\n * Returns a new array with items summing up to 1, preserving elements proportionality.\n * When the given array is empty, returns an empty array.\n *\n * @param {Array} arr\n * @returns {Array}\n */\nexport const scaleToOne = arr => {\n  if (arr.length === 0) return [];\n  const arrSum = sum(arr);\n  return arr.map(x => arrSum !== 0 ? x / arrSum : 1 / arr.length);\n};\n\n/**\n * Applies the given function to the elements and returns the first truthy value of these calls.\n *\n * @param {Array} arr\n * @returns {*}\n */\nexport const firstResult = (arr, fn) =>\n  arr.reduce((result, x) => result || fn(x), null);\n\nexport const flatMap = (arr, fn) =>\n  arr.reduce((xs, x) => xs.concat(fn(x)), []);\n\nexport const groupBy = (arr, fn) =>\n  arr.reduce((obj, x) =>\n    updateIn(obj, [fn(x)], xs => (xs || []).concat(x))\n  , {});\n\nexport const zip = (...arrs) =>\n  arrs.length === 0 ? [] : arrs[0].map((_, i) => arrs.map(arr => arr[i]));\n\nexport const findLast = (arr, predicate) =>\n  arr.reduceRight((found, x) =>\n    found !== undefined ? found : (predicate(x) ? x : undefined)\n  , undefined);\n\nexport const intersection = (xs, ys) =>\n  xs.filter(x => ys.includes(x));\n\nexport const difference = (xs, ys) =>\n  xs.filter(x => !ys.includes(x));\n\nexport const partition = (xs, fn) =>\n  [xs.filter(fn), xs.filter(x => !fn(x))];\n\nconst sortCompare = (x, y) =>\n  x < y ? -1 : (x > y ? 1 : 0);\n\nexport const sortBy = (arr, fn) =>\n  arr.slice().sort((x, y) => sortCompare(fn(x), fn(y)));\n\nexport const sortByArray = (arr, fn) => {\n  const values = new Map(arr.map(x => [x, fn(x)])); /* Compute every value once. */\n  return arr.slice().sort((x, y) =>\n    firstResult(zip(values.get(x), values.get(y)), ([a, b]) => sortCompare(a, b))\n  );\n}\n\nexport const chunk = (arr, size) =>\n  arr.length <= size\n    ? [arr]\n    : [arr.slice(0, size), ...chunk(arr.slice(size), size)];\n\nexport const times = (n, fn) =>\n  Array.from({ length: n }, (_, index) => fn(index));\n\nexport const uniq = arr =>\n  [...new Set(arr)];\n\nexport const sum = arr =>\n  arr.reduce((x, y) => x + y, 0);\n\nexport const pick = (obj, keys) =>\n  keys.reduce((newObj, key) => ({ ...newObj, [key]: obj[key] }), {});\n\nexport const inRange = (x, a, b) =>\n  a <= x && x <= b;\n\nexport const addMilliseconds = (isoString, milliseconds) =>\n  new Date(new Date(isoString).getTime() + milliseconds).toISOString();\n\nexport const isoTimeDiff = (first, second) =>\n  Math.abs(new Date(first) - new Date(second));\n\nexport const shortTime = (isoString, timeZone = 'UTC') =>\n  new Date(isoString).toLocaleTimeString('en-US', { timeZone, hour: 'numeric', minute: 'numeric' });\n\nexport const reorderArray = (arr, from, to) => {\n    const [removed] = arr.splice(from, 1);\n    arr.splice(to, 0, removed);\n}\n","const formats = [{\n  id: '1',\n  name: 'Best of 1',\n  shortName: 'Bo1',\n  solveCount: 1,\n  cutoffFormats: [],\n  sortBy: 'best',\n}, {\n  id: '2',\n  name: 'Best of 2',\n  shortName: 'Bo2',\n  solveCount: 2,\n  cutoffFormats: ['1'],\n  sortBy: 'best',\n}, {\n  id: '3',\n  name: 'Best of 3',\n  shortName: 'Bo3',\n  solveCount: 3,\n  cutoffFormats: ['1', '2'],\n  sortBy: 'best',\n}, {\n  id: 'm',\n  name: 'Mean of 3',\n  shortName: 'Mo3',\n  solveCount: 3,\n  cutoffFormats: ['1', '2'],\n  sortBy: 'average',\n}, {\n  id: 'a',\n  name: 'Average of 5',\n  shortName: 'Ao5',\n  solveCount: 5,\n  cutoffFormats: ['1', '2', '3'],\n  sortBy: 'average',\n}];\n\nexport const formatById = id =>\n  formats.find(format => format.id === id);\n","import { flatMap, updateIn, groupBy, sortBy } from './utils';\nimport { idsFromRound } from './wcif';\nimport { formatById } from './formats';\n\nlet uniqueScrambleSetId = 1;\n\n// The WCIF defines the following fields:\n// { id, scrambles: [], extraScrambles: [] }\n// Internally we want to store a couple more information:\n// {\n//   sheetName: String, title: String, generatedAttemptNumber: null|Integer,\n//   eventId: String, roundNumber: Integer\n// }\n// This will let us easily (automatically) match and display scrambles in the WCIF.\n// Keeping in mind we'll need to support loading scrambles from the uploaded WCIF!\nconst tnoodleSheetsToInternal = (filename, sheets) => sheets.map(sheet => {\n    return {\n      id: uniqueScrambleSetId++,\n      scrambles: sheet.scrambles || [],\n      extraScrambles: sheet.extraScrambles || [],\n      title: sheet.title,\n      sheetName: filename,\n      generatedAttemptNumber: sheet.generatedAttemptNumber,\n      eventId: sheet.event,\n      roundNumber: sheet.round,\n    }\n});\n\nconst splitMultiFm = scramble => {\n  let attemptNumber = 1;\n  // Split the scramble to have one object per attempt (will be useful later ;))\n  return scramble.scrambles.map(sequence => { return {\n    ...scramble,\n    scrambles: [sequence],\n    title: `${scramble.title} Attempt ${attemptNumber}`,\n    scrambleSetId: `${scramble.scrambleSetId}-a${attemptNumber}`,\n    generatedAttemptNumber: attemptNumber++,\n  }});\n}\n\nconst addScrambleSetsIfMissing = rounds => rounds.map(r => {\n  return {\n    ...r,\n    scrambleSets: r.scrambleSets || [],\n  }\n});\n\nconst scrambleSetsForRound = (usedScramblesId, round, uploadedScrambles) => {\n  // We don't want to overwrite existing scrambles,\n  // so for all rounds *without* scramble we:\n  //   - for all scramble in uploadedScrambles (in order they were uploaded):\n  //     - look for a set of matching (event, round number)\n  // This way if we ever upload multiple sets of scramble for the same round\n  // we just assign the first one (as the others are likely extra scrambles used\n  // in rounds we can't figure out programatically !).\n  // We also want to return a new WCIF as the wcif passed is most likely taken\n  // from a React state.\n  const [eventId, roundNumber] = idsFromRound(round);\n  let firstMatchingSheets = [];\n  uploadedScrambles.find(up => {\n    firstMatchingSheets = up.sheets.filter(s => !usedScramblesId.includes(s.id) && s.eventId === eventId && s.roundNumber === roundNumber);\n    return firstMatchingSheets.length !== 0;\n  });\n  // We don't actually need to update the usedScramblesId, because we never try to\n  // get the same eventId/roundNumber again, so usedScramblesId only need to\n  // contain the scrambles in use before the autoAssign thing.\n  if ([\"333fm\", \"333mbf\"].includes(eventId)) {\n    // Select scrambles which match the attempt number(s) expected,\n    // and assign the attemptNumber from the generated number\n    let numberOfAttempts = formatById(round.format).solveCount;\n    return firstMatchingSheets.filter(s => s.generatedAttemptNumber <= numberOfAttempts).map(s => {\n      return {\n        ...s,\n        attemptNumber: s.generatedAttemptNumber,\n      };\n    });\n  } else {\n    return firstMatchingSheets;\n  }\n};\n\nexport const allScramblesForEvent = (scrambles, eventId, usedIds) =>\n  flatMap(scrambles, scramble => scramble.sheets.filter(s => (s.eventId === eventId && !usedIds.includes(s.id))));\n\nexport const usedScramblesIdsForEvent = (events, eventId) =>\n  flatMap(flatMap(events.filter(e => e.id === eventId), e => flatMap(e.rounds, r => r.scrambleSets)), s => s.id);\n\nexport const updateMultiAndFm = scrambles => flatMap(scrambles, s => (s.event === \"333fm\" || s.event === \"333mbf\") ? splitMultiFm(s) : s)\n\nexport const ensureScramblesMember = events => events.map(e => updateIn(e, [\"rounds\"], addScrambleSetsIfMissing));\n\nexport const transformUploadedScrambles = uploadedJson => {\n  const updater = sheets => tnoodleSheetsToInternal(uploadedJson.competitionName, sheets);\n  return updateIn(uploadedJson, [\"sheets\"], updater);\n};\n\n// 65 is the char code for 'A'\nexport const prefixForIndex = index => String.fromCharCode(65 + index);\n\nexport const internalScramblesToWcifScrambles = (eventId, scrambles) => {\n  if (scrambles.length === 0)\n    return scrambles;\n  if (eventId === \"333mbf\") {\n    // We need to combine all scrambles for each attempt,\n    // in the end there will be one scramble sheet with X scramble sequences,\n    // where X is the number of attempts.\n    let scramblesByAttempt = groupBy(scrambles, s => s.attemptNumber);\n    let sheet = {\n      id: scrambles[0].id,\n      scrambles: [],\n      extraScrambles: [],\n    }\n    Object.keys(scramblesByAttempt).sort().forEach(number =>\n      sheet.scrambles.push(scramblesByAttempt[number].map(s => s.scrambles).join(\"\\n\")));\n    return [sheet];\n  } else if (eventId === \"333fm\") {\n    // We can't track yet in the WCIF which scramble was for witch attempt,\n    // so let's just sort them by attempt id and combine them in one\n    // scramble sheet.\n    // There is usually only one group for FM, the only case where we would\n    // like more scramble than expected is when something terrible happened\n    // and an extra was needed.\n    return [{\n      id: scrambles[0].id,\n      scrambles: flatMap(sortBy(scrambles, s => s.attemptNumber), s => s.scrambles),\n      extraScrambles: [],\n    }];\n  }\n  return scrambles.map(set => {\n    return {\n      id: set.id,\n      scrambles: set.scrambles,\n      extraScrambles: set.extraScrambles,\n    }\n  });\n};\n\nexport const autoAssignScrambles = (wcif, uploadedScrambles) => {\n  let usedScrambleIdsByEvent = {};\n  wcif.events.forEach(e => {\n    usedScrambleIdsByEvent[e.id] = usedScramblesIdsForEvent(wcif.events, e.id);\n  });\n  return {\n    ...wcif,\n    events: wcif.events.map(e => {\n      return {\n        ...e,\n        rounds: e.rounds.map(r => {\n          return {\n            ...r,\n            scrambleSets: r.scrambleSets.length === 0\n              ? scrambleSetsForRound(usedScrambleIdsByEvent[e.id], r, uploadedScrambles)\n              : r.scrambleSets,\n          };\n        }),\n      };\n    }),\n  };\n}\n\nexport const clearScrambles = wcif => {\n  return {\n    ...wcif,\n    events: wcif.events.map(e => {\n      return {\n        ...e,\n        rounds: e.rounds.map(r => {\n          return {\n            ...r,\n            scrambleSets: [],\n          };\n        }),\n      };\n    }),\n  };\n}\n","import { flatMap } from './utils';\nimport wca_states from '../wca_data/wca-states.json';\n\nconst countries = flatMap(wca_states.states_lists, list => list.states);\n\nexport const countryByIso2 = iso2 =>\n  countries.find(country => country.iso2 === iso2);\n\nexport const countryById = id =>\n  countries.find(country => country.id === id);\n","const roundTypes = [{\n  id: '0',\n  rank: 19,\n  name: 'Qualification round',\n  cellName: 'Qualification',\n  isFinal: 0,\n}, {\n  id: '3',\n  rank: 79,\n  name: 'Semi Final',\n  cellName: 'Semi Final',\n  isFinal: 0,\n}, {\n  id: 'b',\n  rank: 39,\n  name: 'B Final',\n  cellName: 'B Final',\n  isFinal: 0,\n}, {\n  id: 'c',\n  rank: 90,\n  name: 'Combined Final',\n  cellName: 'Combined Final',\n  isFinal: 1,\n}, {\n  id: 'd',\n  rank: 20,\n  name: 'Combined First round',\n  cellName: 'Combined First',\n  isFinal: 0,\n}, {\n  id: 'e',\n  rank: 59,\n  name: 'Combined Second round',\n  cellName: 'Combined Second',\n  isFinal: 0,\n}, {\n  id: 'f',\n  rank: 99,\n  name: 'Final',\n  cellName: 'Final',\n  isFinal: 1,\n}, {\n  id: 'g',\n  rank: 70,\n  name: 'Combined Third round',\n  cellName: 'Combined Third',\n  isFinal: 0,\n}, {\n  id: '1',\n  rank: 29,\n  name: 'First round',\n  cellName: 'First',\n  isFinal:  0,\n}, {\n  id: '2',\n  rank: 50,\n  name: 'Second round',\n  cellName: 'Second',\n  isFinal: 0,\n}, {\n  id: 'h',\n  rank: 10,\n  name: 'Combined qualification',\n  cellName: 'Combined qualification',\n  isFinal: 0,\n}];\n\nexport const roundTypeById = id =>\n  roundTypes.find(t => t.id === id);\n\nexport const roundTypeFromCellName = cellName =>\n  roundTypes.find(t => cellName.includes(t.cellName));\n","import { sortBy } from './utils';\nimport { idsFromRound } from './wcif';\nimport { roundTypeById } from './roundtypes';\n\nconst events = [\n  { id: '333',    name: '3x3x3 Cube',         shortName: '3x3'   },\n  { id: '222',    name: '2x2x2 Cube',         shortName: '2x2'   },\n  { id: '444',    name: '4x4x4 Cube',         shortName: '4x4'   },\n  { id: '555',    name: '5x5x5 Cube',         shortName: '5x5'   },\n  { id: '666',    name: '6x6x6 Cube',         shortName: '6x6'   },\n  { id: '777',    name: '7x7x7 Cube',         shortName: '7x7'   },\n  { id: '333bf',  name: '3x3x3 Blindfolded',  shortName: '3BLD'  },\n  { id: '333fm',  name: '3x3x3 Fewest Moves', shortName: 'FMC'   },\n  { id: '333oh',  name: '3x3x3 One-Handed',   shortName: '3OH'   },\n  { id: '333ft',  name: '3x3x3 With Feet',    shortName: '3WF'   },\n  { id: 'minx',   name: 'Megaminx',           shortName: 'Minx'  },\n  { id: 'pyram',  name: 'Pyraminx',           shortName: 'Pyra'  },\n  { id: 'clock',  name: 'Clock',              shortName: 'Clock' },\n  { id: 'skewb',  name: 'Skewb',              shortName: 'Skewb' },\n  { id: 'sq1',    name: 'Square-1',           shortName: 'Sq1'   },\n  { id: '444bf',  name: '4x4x4 Blindfolded',  shortName: '4BLD'  },\n  { id: '555bf',  name: '5x5x5 Blindfolded',  shortName: '5BLD'  },\n  { id: '333mbf', name: '3x3x3 Multi-Blind',  shortName: 'MBLD'  }\n];\n\nexport const eventNameById = eventId =>\n  propertyById('name', eventId);\n\nexport const shortEventNameById = eventId =>\n  propertyById('shortName', eventId);\n\nconst propertyById = (property, eventId) =>\n  events.find(event => event.id === eventId)[property];\n\nexport const sortWcifEvents = wcifEvents =>\n  sortBy(wcifEvents, wcifEvent => events.findIndex(event => event.id === wcifEvent.id));\n\nexport const roundTypeIdForRound = (numberOfRounds, round) => {\n  // This is the case if we loaded a XLSX!\n  if (round.roundTypeId)\n    return round.roundTypeId;\n\n  let [, roundNumber] = idsFromRound(round);\n  if (roundNumber === numberOfRounds) {\n    return round.cutoff ? 'c' : 'f';\n  }\n  if (roundNumber === 1) {\n    return round.cutoff ? 'd' : '1';\n  }\n  if (roundNumber === 2) {\n    return round.cutoff ? 'e' : '2';\n  }\n  if (roundNumber === 3) {\n    return round.cutoff ? 'g' : '3'\n  }\n  return \"<oops>\";\n};\n\nexport const roundName = (numberOfRounds, round) => {\n  let [eventId, ] = idsFromRound(round);\n  return `${eventNameById(eventId)} - ${roundTypeById(roundTypeIdForRound(numberOfRounds, round)).name}`;\n};\n","import { internalScramblesToWcifScrambles, prefixForIndex } from './scrambles';\nimport { countryById } from './countries';\nimport { formatById } from './formats';\nimport { groupBy } from './utils';\nimport { roundTypeIdForRound } from './events';\n\n// TODO: implement a proper \"allScramblePresent\" function\n// For attempt-based event (mbf, fm), we should not only check that we have one scramble,\n// but one scramble for each attempt.\n\nexport const eventIdFromRound = round => round.id.split(\"-\")[0];\nexport const roundNumberFromRound = round => round.id.split(\"-\")[1].substring(1);\n\nexport const idsFromRound = round => {\n  let [eventId, roundNumber] = round.id.split(\"-r\");\n  roundNumber = parseInt(roundNumber);\n  return [eventId, roundNumber];\n};\n\nexport const registrantIdFromAttributes = (persons, name, country, wcaId) =>\n  persons.find(p => p.name === name && p.country === country && p.wcaId === wcaId).registrantId;\n\nconst WcifScramblesToResultsGroups = scrambles => scrambles.map((sheet, index) => {\n  return {\n    group: prefixForIndex(index),\n    scrambles: sheet.scrambles,\n    extraScrambles: sheet.extraScrambles || [],\n  };\n});\n\nexport const internalWcifToWcif = wcif => {\n  // We only alter the scrambles, so make them right wrt the WCIF.\n  return {\n    ...wcif,\n    events: wcif.events.map(e => {\n      return {\n        ...e,\n        rounds: e.rounds.map(r => {\n          return {\n            ...r,\n            scrambleSets: internalScramblesToWcifScrambles(e.id, r.scrambleSets),\n          }\n        }),\n      };\n    }),\n  }\n};\n\nexport const internalWcifToResultsJson = (wcif, version) => {\n  return {\n    formatVersion: \"WCA Competition 0.3\",\n    competitionId: wcif.id,\n    persons: wcif.persons.map(p => {\n      return {\n        id: p.registrantId,\n        name: p.name,\n        wcaId: p.wcaId || \"\",\n        countryId: countryById(p.country).iso2,\n        gender: p.gender || \"\",\n        dob: p.birthdate,\n      };\n    }),\n    events: wcif.events.map(e => {\n      return {\n        eventId: e.id,\n        rounds: e.rounds.map(r => {\n          return {\n            roundId: roundTypeIdForRound(e.rounds.length, r),\n            formatId: r.format,\n            results: r.results.map(res => {\n              return {\n                personId: res.personId,\n                position: res.ranking,\n                results: res.attempts.map(a => a.result),\n                best: res.best,\n                average: res.average,\n              };\n            }),\n            groups: WcifScramblesToResultsGroups(internalScramblesToWcifScrambles(e.id,\n              r.scrambleSets)),\n          }\n        }),\n      }\n    }),\n    // TODO: make sure that only one tnoodle was used, then add an explicit field for that?\n    scrambleProgram: wcif.scrambleProgram,\n    resultsProgram: `Scrambles Matcher ${version}`,\n  };\n};\n\nexport const competitionLink = id => `https://www.worldcubeassociation.org/competitions/${id}`;\n\nexport const competitionHasValidScrambles = wcif =>\n  wcif.events.every(e => eventHasValidScrambles(e));\n\nexport const eventHasValidScrambles = event =>\n  event.rounds.every(r => roundHasValidScrambles(event.id, r));\n\nexport const roundHasValidScrambles = (eventId, round) =>\n  // Just taking eventId to avoid some splitting of round.id\n  [\"333mbf\", \"333fm\"].includes(eventId)\n    ? Object.keys(groupBy(round.scrambleSets, s => s.attemptNumber)).length === formatById(round.format).solveCount\n    : round.scrambleSets.length !== 0;\n","import React, { Fragment, useState } from 'react';\nimport Collapse from '@material-ui/core/Collapse';\nimport List from '@material-ui/core/List';\nimport ListItem from '@material-ui/core/ListItem';\nimport ListItemIcon from '@material-ui/core/ListItemIcon';\nimport ListItemText from '@material-ui/core/ListItemText';\nimport Tooltip from '@material-ui/core/Tooltip';\nimport { makeStyles, withStyles } from '@material-ui/core/styles';\nimport InfoIcon from '@material-ui/icons/Info';\nimport ReportProblemIcon from '@material-ui/icons/ReportProblem';\nimport classnames from 'classnames';\n\nimport CubingIcon from '../../CubingIcon/CubingIcon';\nimport { eventHasValidScrambles, roundHasValidScrambles } from '../../../logic/wcif';\nimport { eventNameById, roundTypeIdForRound } from '../../../logic/events';\nimport { roundTypeById } from '../../../logic/roundtypes';\n\nconst EventListItem = withStyles({\n  root: {\n    color: 'black',\n    '& .cubing-icon, & svg': {\n      color: 'black',\n    },\n  }\n})(ListItem);\n\nconst useStyles = makeStyles(theme => ({\n  item: {\n    paddingLeft: theme.spacing(4),\n  },\n  svg: {\n    '& svg': {\n      color: 'red',\n    }\n  }\n}));\n\nconst CompetitionMenu = ({ events, setSelectedRound }) => {\n  const [selectedEvent, setSelectedEvent] = useState(null);\n  const classes = useStyles();\n  return (\n    <List dense={true}>\n      <EventListItem button onClick={() => setSelectedRound(null)}>\n        <ListItemIcon>\n          <InfoIcon />\n        </ListItemIcon>\n        <ListItemText primary=\"Information\" />\n      </EventListItem>\n      {events.map(event => (\n        <Fragment key={event.id}>\n          <EventListItem\n            button\n            onClick={e => {\n              setSelectedEvent(selectedEvent === event.id ? null : event.id);\n              e.stopPropagation();\n            }}\n          >\n            <ListItemIcon>\n              <CubingIcon eventId={event.id} />\n            </ListItemIcon>\n            <ListItemText primary={eventNameById(event.id)} />\n            {!eventHasValidScrambles(event) && (\n              <ListItemIcon className={classes.svg}>\n                <Tooltip title=\"Missing scrambles\">\n                  <ReportProblemIcon />\n                </Tooltip>\n              </ListItemIcon>\n            )}\n          </EventListItem>\n          <Collapse\n            in={selectedEvent === event.id}\n            timeout=\"auto\"\n            unmountOnExit\n          >\n            <List dense={true}>\n              {event.rounds.map(round => (\n                <ListItem\n                  key={round.id}\n                  button\n                  className={classnames(classes.svg, classes.item)}\n                  onClick={() => setSelectedRound(round.id)}\n                >\n                  <ListItemText primary={roundTypeById(roundTypeIdForRound(event.rounds.length, round)).name} />\n                  {!roundHasValidScrambles(event.id, round) && (\n                    <ListItemIcon>\n                      <Tooltip title=\"Missing scrambles\">\n                        <ReportProblemIcon />\n                      </Tooltip>\n                    </ListItemIcon>\n                  )}\n                </ListItem>\n              ))}\n            </List>\n          </Collapse>\n        </Fragment>\n      ))}\n    </List>\n  );\n};\n\nexport default CompetitionMenu;\n","import React from 'react';\nimport List from '@material-ui/core/List';\nimport ListItem from '@material-ui/core/ListItem';\nimport ListItemText from '@material-ui/core/ListItemText';\nimport { Droppable, Draggable } from \"react-beautiful-dnd\";\nimport { styled } from '@material-ui/styles';\n\nimport { prefixForIndex } from '../../logic/scrambles';\n\nconst DNDList = styled(List)({\n  minHeight: \"100px\",\n});\n\nconst getItemStyle = (isDragging, draggableStyle) => ({\n  // styles we need to apply on draggables\n  ...draggableStyle,\n\n  ...(isDragging && {\n    background: \"rgb(235,235,235)\"\n  })\n});\n\nconst DraggableScramble = ({ s, index, showPrefix }) => (\n  <Draggable draggableId={s.id} index={index}>\n    {(provided, snapshot) =>(\n      <ListItem button\n        ref={provided.innerRef}\n        {...provided.draggableProps}\n        {...provided.dragHandleProps}\n        style={getItemStyle(snapshot.isDragging, provided.draggableProps.style)}\n      >\n        {showPrefix && !snapshot.isDragging && (\n          <ListItemText primary={prefixForIndex(index)} />\n        )}\n        <ListItemText primary={s.title} secondary={`From ${s.sheetName}`} />\n      </ListItem>\n    )}\n  </Draggable>\n);\n\nconst ScrambleList = ({ scrambles, holds }) => (\n  <Droppable droppableId={holds}>\n    {(provided, snapshot) => (\n      <DNDList\n        {...provided.droppableProps}\n        ref={provided.innerRef}\n      >\n        {scrambles.map((s, index) => (\n          <DraggableScramble key={s.id} s={s} index={index}\n            showPrefix={holds === \"round\"}\n          />\n        ))}\n        {false && scrambles.length === 0 && (\n          <ListItem key={0}>\n            No scrambles\n          </ListItem>\n        )}\n        {provided.placeholder}\n      </DNDList>\n    )}\n  </Droppable>\n);\n\nexport default ScrambleList;\n","import React, { Component, Fragment } from 'react';\nimport Paper from '@material-ui/core/Paper';\nimport Grid from '@material-ui/core/Grid';\nimport Typography from '@material-ui/core/Typography';\nimport { DragDropContext } from \"react-beautiful-dnd\";\nimport { withStyles } from '@material-ui/core/styles';\n\nimport ScrambleList from '../../Scrambles/ScrambleList';\nimport { groupBy, flatMap } from '../../../logic/utils';\nimport { roundName } from '../../../logic/events';\nimport { formatById } from '../../../logic/formats';\n\nconst SpacedPaper = withStyles(theme => ({\n  root: {\n    marginBottom: theme.spacing(4),\n  }\n}))(Paper);\n\n\nconst attemptFromDroppable = elem => parseInt(elem.droppableId.split(\"-\")[1]);\n\nconst ListForGenericRound = ({ round }) => (\n  <Paper>\n    <Typography variant=\"h4\">\n      Used for round\n    </Typography>\n    <ScrambleList scrambles={round.scrambleSets} holds=\"round\" />\n  </Paper>\n);\n\nconst ListForAttemptBasedRound = ({ round }) => {\n  const nAttempts = formatById(round.format).solveCount;\n  let attempts = [...Array(nAttempts).keys()].map(i => ++i);\n  return (\n    <Fragment>\n      {attempts.map(index => (\n        <SpacedPaper key={index}>\n          <Typography variant=\"h4\">\n            Used for attempt {index}\n          </Typography>\n          <ScrambleList\n            scrambles={round.scrambleSets.filter(s => s.attemptNumber === index)}\n            holds={`round-${index}`}\n          />\n        </SpacedPaper>\n      ))}\n    </Fragment>\n  );\n}\n\n\nexport default class RoundPanel extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      availableScrambles: this.props.availableScrambles,\n    };\n  }\n\n  componentDidUpdate(prevProps) {\n    let prevIds = this.state.availableScrambles.map(s => s.id).sort();\n    let newIds = this.props.availableScrambles.map(s => s.id).sort();\n\n    if (newIds.join(\"\") !== prevIds.join(\"\")) {\n      this.setState({\n        availableScrambles: this.props.availableScrambles,\n      });\n    }\n  }\n\n  handleGenericMove = (source, destination) => {\n    const { round, attachScramblesToRound } = this.props;\n    const { availableScrambles } = this.state;\n    // Whatever we do, we just need to update the parent state\n    let scrambles = source.droppableId === \"available\"\n      ? availableScrambles\n      : round.scrambleSets;\n    let scramble = scrambles.splice(source.index, 1)[0];\n\n    let destScrambles = destination.droppableId === source.droppableId\n      ? scrambles\n      : destination.droppableId === \"round\"\n        ? round.scrambleSets\n        : availableScrambles;\n\n    // Insert the scramble to the new array at the correct spot\n    destScrambles.splice(destination.index, 0, scramble);\n\n    if (destination.droppableId === \"available\" && source.droppableId === \"available\")\n      this.setState({ availableScrambles: destScrambles });\n    else if (destination.droppableId === \"round\")\n      attachScramblesToRound(destScrambles, round);\n    else\n      attachScramblesToRound(scrambles, round);\n  }\n\n  handleAttemptBasedMove = (source, destination) => {\n    const { round, attachScramblesToRound } = this.props;\n    const { availableScrambles } = this.state;\n    // Again we just need to update the parent state\n    let scrambles = round.scrambleSets;\n    // Group round's scrambles based on attempt number\n    let scramblesByAttempt = groupBy(scrambles, s => s.attemptNumber);\n    let scramble = null;\n    scramble = source.droppableId === \"available\"\n      ? availableScrambles[source.index]\n      : scramblesByAttempt[attemptFromDroppable(source)].splice(source.index, 1)[0];\n\n    if (destination.droppableId !== \"available\") {\n      let destAttempt = attemptFromDroppable(destination);\n      // update the attempt number\n      scramble.attemptNumber = destAttempt;\n      // if that's the first scramble we move there, the entry won't exist yet\n      scramblesByAttempt[destAttempt] = scramblesByAttempt[destAttempt] || [];\n      // actually move the scramble to the appropriate list\n      scramblesByAttempt[destAttempt].splice(destination.index, 0, scramble);\n    }\n\n    // Concatenate everything for the update\n    scrambles = flatMap(Object.keys(scramblesByAttempt), k => scramblesByAttempt[k]);\n    attachScramblesToRound(scrambles, round);\n  }\n\n  handleScrambleMovement = result => {\n    const { source, destination } = result;\n\n    // dropped outside the list\n    if (!destination) {\n      return;\n    }\n\n    if (source.droppableId.includes(\"-\") || destination.droppableId.includes(\"-\"))\n      this.handleAttemptBasedMove(source, destination);\n    else\n      this.handleGenericMove(source, destination);\n  };\n\n  // TODO: save to main wcif button\n\n  render() {\n    const { event, round } = this.props;\n    const { availableScrambles } = this.state;\n    return (\n      <DragDropContext onDragEnd={this.handleScrambleMovement}>\n        <Typography variant=\"h3\" align=\"center\">\n          {roundName(event.rounds.length, round)}\n        </Typography>\n        <Grid container justify=\"center\">\n          <Grid item xs={6} md={4} style={{ padding: 16 }} align=\"center\">\n            {[\"333mbf\", \"333fm\"].includes(event.id) ? (\n              <ListForAttemptBasedRound round={round} />\n            ) : (\n              <ListForGenericRound round={round} />\n            )}\n          </Grid>\n          <Grid item xs={6} md={4} style={{ padding: 16 }} align=\"center\">\n            <Paper>\n              <Typography variant=\"h4\">\n                Available\n              </Typography>\n              <ScrambleList scrambles={availableScrambles} holds=\"available\" />\n            </Paper>\n          </Grid>\n        </Grid>\n      </DragDropContext>\n    );\n  }\n};\n","import React from 'react';\nimport Paper from '@material-ui/core/Paper';\nimport Button from '@material-ui/core/Button';\nimport ButtonGroup from '@material-ui/core/ButtonGroup';\nimport Link from '@material-ui/core/Link';\nimport Typography from '@material-ui/core/Typography';\nimport TextField from '@material-ui/core/TextField';\n\nimport { competitionLink } from '../../../logic/wcif';\n\nconst LinkToNewPage = props => {\n  const { block, ...extraProps } = props;\n  return (\n    <Link {...extraProps} target=\"_blank\" rel=\"noreferrer\">\n      { block }\n    </Link>\n  );\n};\n\nconst HelperWithLink = ({ id }) => (\n  <span>\n    The ID is correct if and only\n    if <LinkToNewPage href={`${competitionLink(id)}`} block=\"this link\" /> opens\n    your competition's page.\n  </span>\n);\n\nconst CompetitionDetailsPanel = (props) => {\n  const {\n    wcif, downloadWcifAction,\n    downloadResultsJsonAction, classes,\n    uploadCompetitionIdAction\n  } = props;\n\n  const exportAvailable = wcif.id;\n  // For now allow export even if missing scrambles.\n  // && competitionHasValidScrambles(wcif);\n\n  const handleNameChange = ev => uploadCompetitionIdAction(ev.target.value);\n  return (\n    <Paper className={classes.paper}>\n      <Typography variant=\"h4\" className={classes.h}>\n        Competition details\n      </Typography>\n      <form className={classes.mb3} noValidate autoComplete=\"off\">\n        <TextField\n          id=\"outlined-name\"\n          label=\"Competition ID\"\n          //className={classes.textField}\n          value={wcif.id || \"\"}\n          onChange={handleNameChange}\n          helperText={<HelperWithLink id={wcif.id} />}\n          margin=\"normal\"\n          variant=\"outlined\"\n        />\n      </form>\n      <Typography paragraph>\n        When you have make sure your competition ID is correct and all your rounds\n        have the correct scrambles, you can get the export you want below.\n      </Typography>\n      <ButtonGroup variant=\"contained\" color=\"primary\"\n        aria-label=\"outlined primary button group\"\n          disabled={!exportAvailable}\n      >\n        <Button\n          onClick={downloadWcifAction}\n        >\n          Get WCIF\n        </Button>\n        <Button\n          onClick={downloadResultsJsonAction}\n        >\n          Get results JSON\n        </Button>\n      </ButtonGroup>\n    </Paper>\n  );\n};\n\nexport default CompetitionDetailsPanel;\n","import React from 'react';\nimport Paper from '@material-ui/core/Paper';\nimport Button from '@material-ui/core/Button';\nimport Grid from '@material-ui/core/Grid';\nimport Typography from '@material-ui/core/Typography';\nimport FreeBreakfastIcon from '@material-ui/icons/FreeBreakfast';\nimport DeleteIcon from '@material-ui/icons/Delete';\nimport classnames from 'classnames';\nimport { green } from '@material-ui/core/colors';\nimport { withStyles } from '@material-ui/core/styles';\n\nconst GreenButton = withStyles(theme => ({\n  root: {\n    color: theme.palette.getContrastText(green[500]),\n    backgroundColor: green[500],\n    '&:hover': {\n      backgroundColor: green[700],\n    },\n  },\n}))(Button);\n\nconst MatchingScramblesPanel = ({ assignAction, clearAction, uploadAction, classes }) => {\n  return (\n    <Paper className={classes.paper}>\n      <Typography variant=\"h4\" className={classes.h}>\n        Matching scrambles to rounds\n      </Typography>\n      <Typography paragraph align=\"justify\">\n        Clicking \"Automatically assign scrambles\" will attempt to automatically\n        detect which scrambles sets belongs to which round.\n        Unlike the workbook assistant, this will attempt to assign unused scrambles\n        only to rounds <b>without</b> scrambles! Which means that clicking several\n        times the button with the same uploaded scrambles will have no effect.\n        <br/>\n        You can check scrambles assignments by browsing through the rounds in\n        the menu.\n        For each round (or each attempt for Multiple Blindfolded and Fewest Moves)\n        you can assign scrambles manually from the unused scrambles in the\n        uploaded scrambles.\n        <br/>\n        When everything looks good, get the Results JSON to import the results\n        on the WCA website.\n        <br/>\n        Don't forget to set the competition ID if it's not detected!\n      </Typography>\n      <Grid container direction=\"row\">\n        <Grid item xs={12}>\n          <input\n            accept=\".json\"\n            className={classes.input}\n            id=\"add-scramble-json\"\n            multiple\n            type=\"file\"\n            onChange={uploadAction}\n          />\n          <label htmlFor=\"add-scramble-json\">\n            <GreenButton variant=\"contained\"\n              component=\"span\"\n              color=\"primary\"\n              className={classnames(classes.addJsonButton, classes.mb3)}\n            >\n              Upload scrambles json\n            </GreenButton>\n          </label>\n        </Grid>\n        <Grid item xs={6} style={{ paddingRight: 8 }}>\n          <Button variant=\"contained\" component=\"span\"\n            color=\"primary\"\n            fullWidth\n            className={classes.button}\n            onClick={assignAction}\n          >\n            <FreeBreakfastIcon className={classes.extendedIcon} />\n            Automatically assign scrambles\n          </Button>\n        </Grid>\n        <Grid item xs={6} style={{ paddingLeft: 8 }}>\n          <Button variant=\"contained\" color=\"secondary\"\n            fullWidth\n            className={classes.button}\n            onClick={clearAction}\n          >\n            <DeleteIcon className={classes.extendedIcon} />\n            Clear scrambles assignments\n          </Button>\n        </Grid>\n      </Grid>\n    </Paper>\n  );\n};\n\nexport default MatchingScramblesPanel;\n","import React, { useState, Fragment } from 'react';\nimport { withStyles, makeStyles } from '@material-ui/core/styles';\nimport Card from '@material-ui/core/Card';\nimport Link from '@material-ui/core/Link';\nimport CardHeader from '@material-ui/core/CardHeader';\nimport CardContent from '@material-ui/core/CardContent';\nimport IconButton from '@material-ui/core/IconButton';\nimport List from '@material-ui/core/List';\nimport ListItem from '@material-ui/core/ListItem';\nimport ExpandMoreIcon from '@material-ui/icons/ExpandMore';\nimport Typography from '@material-ui/core/Typography';\nimport Collapse from '@material-ui/core/Collapse';\nimport clsx from 'clsx';\n\nconst useStyles = makeStyles(theme => ({\n  expand: {\n    transform: 'rotate(0deg)',\n    transition: theme.transitions.create('transform', {\n      duration: theme.transitions.duration.shortest,\n    }),\n  },\n  expandOpen: {\n    transform: 'rotate(180deg)',\n  },\n  card: {\n    marginBottom: theme.spacing(2),\n  }\n}));\n\nconst NestedScrambleItem = withStyles(theme => ({\n  root: {\n    paddingLeft: theme.spacing(4),\n  }\n}))(ListItem);\n\nconst ScrambleFileInfo = ({ scramble }) => {\n  const classes = useStyles();\n  const [expanded, setExpanded] = useState(false);\n\n  function handleExpandClick() {\n    setExpanded(!expanded);\n  }\n\n  return (\n    <Card className={classes.card}>\n      <CardHeader\n        action={\n          <IconButton\n            className={clsx(classes.expand, {\n              [classes.expandOpen]: expanded,\n            })}\n            onClick={handleExpandClick}\n            aria-expanded={expanded}\n            aria-label=\"show more\"\n          >\n            <ExpandMoreIcon />\n          </IconButton>\n        }\n        title={\n          <Link\n            component=\"button\"\n            variant=\"h5\"\n            color=\"inherit\"\n            onClick={handleExpandClick}\n          >\n            {scramble.competitionName}\n          </Link>\n        }\n        subheader={\n          <Fragment>\n            <Typography variant=\"body2\" component=\"p\" color=\"textSecondary\">\n              Generated with {scramble.version}\n            </Typography>\n            <Typography variant=\"body2\" component=\"p\" color=\"textSecondary\">\n              On {scramble.generationDate}\n            </Typography>\n          </Fragment>\n        }\n      />\n      <Collapse in={expanded} timeout=\"auto\" unmountOnExit>\n        <CardContent>\n          <List dense>\n            {scramble.sheets.map(sheet => (\n              <NestedScrambleItem key={sheet.id}>\n                {sheet.title}\n              </NestedScrambleItem>\n            ))}\n          </List>\n        </CardContent>\n      </Collapse>\n    </Card>\n  );\n}\n\nexport default ScrambleFileInfo;\n","import React from 'react';\nimport Paper from '@material-ui/core/Paper';\nimport Typography from '@material-ui/core/Typography';\nimport ScrambleFileInfo from '../../Scrambles/ScrambleFileInfo';\n\nconst UploadedScramblesPanel = ({ uploadedScrambles, classes }) => {\n  return (\n    <Paper className={classes.paper}>\n      <Typography variant=\"h4\" className={classes.h}>\n        Uploaded JSON files: {uploadedScrambles.length}\n      </Typography>\n      {uploadedScrambles.map(s => (\n        <ScrambleFileInfo scramble={s} key={s.competitionName} />\n      ))}\n    </Paper>\n  );\n};\n\nexport default UploadedScramblesPanel;\n","import React, { Fragment } from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport { internalWcifToWcif, internalWcifToResultsJson } from '../../../logic/wcif';\nimport { autoAssignScrambles, clearScrambles } from '../../../logic/scrambles';\nimport CompetitionDetailsPanel from './CompetitionDetailsPanel';\nimport MatchingScramblesPanel from './MatchingScramblesPanel';\nimport UploadedScramblesPanel from './UploadedScramblesPanel';\n\n\nconst downloadFile = (wcif, exporter, filename=\"wcif.json\") => {\n  let blob = new Blob([JSON.stringify(exporter(wcif))], { type: 'application/json' });\n  let blobURL = window.URL.createObjectURL(blob);\n\n  let tmp = document.createElement('a');\n  tmp.href = blobURL;\n  tmp.setAttribute('download', filename);\n  document.body.appendChild(tmp);\n  tmp.click();\n};\n\nconst useStyles = makeStyles(theme => ({\n  input: {\n    display: 'none',\n  },\n  addJsonButton: {\n    width: \"100%\",\n    marginTop: theme.spacing(2),\n  },\n  extendedIcon: {\n    marginRight: theme.spacing(1),\n  },\n  mb3: {\n    marginBottom: theme.spacing(3),\n  },\n  button: {\n    marginRight: theme.spacing(3),\n  },\n  paper: {\n    padding: 16,\n    marginBottom: theme.spacing(2),\n  },\n  h: {\n    marginBottom: theme.spacing(1),\n  }\n}));\n\nconst CompetitionInfo = ({ wcif, uploadedScrambles, uploadAction, handleWcifChange, version }) => {\n  const classes = useStyles();\n\n  const actionDownloadWcif = () => downloadFile(wcif, internalWcifToWcif, `WCIF for ${wcif.name}.json`);\n\n  const actionDownloadResultsJson = () =>\n    downloadFile(wcif, wcif => internalWcifToResultsJson(wcif, version), `Results for ${wcif.name}.json`);\n\n  const actionAssignScrambles = () =>\n    handleWcifChange(autoAssignScrambles(wcif, uploadedScrambles));\n\n  const actionClearScrambles = () =>\n    handleWcifChange(clearScrambles(wcif));\n\n  const uploadCompetitionIdAction = id =>\n    handleWcifChange({ ...wcif, id: id });\n\n  return (\n    <Fragment>\n      <CompetitionDetailsPanel downloadWcifAction={actionDownloadWcif}\n        downloadResultsJsonAction={actionDownloadResultsJson}\n        uploadCompetitionIdAction={uploadCompetitionIdAction}\n        classes={classes}\n        wcif={wcif}\n      />\n      <MatchingScramblesPanel assignAction={actionAssignScrambles}\n        uploadAction={uploadAction}\n        clearAction={actionClearScrambles}\n        classes={classes}\n      />\n      <UploadedScramblesPanel\n        uploadedScrambles={uploadedScrambles}\n        classes={classes}\n      />\n    </Fragment>\n  );\n}\n\nexport default CompetitionInfo;\n","import React, { Component } from 'react';\n\nimport Typography from '@material-ui/core/Typography';\nimport Grid from '@material-ui/core/Grid';\nimport CompetitionMenu from './CompetitionMenu/CompetitionMenu';\nimport RoundPanel from './RoundPanel/RoundPanel';\nimport CompetitionInfo from './CompetitionInfo/CompetitionInfo';\nimport { flatMap, updateIn } from '../../logic/utils';\nimport { eventIdFromRound } from '../../logic/wcif';\nimport { updateMultiAndFm, transformUploadedScrambles, allScramblesForEvent, usedScramblesIdsForEvent } from '../../logic/scrambles';\n\nimport { version } from '../../../package.json';\n\nlet scrambleUploadedId = 1;\n\nexport default class Competition extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      wcif: props.wcif,\n      selectedRoundId: null,\n      uploadedScrambles: [],\n    };\n  }\n\n  componentDidMount() {\n    window.addEventListener('beforeunload', this.handleOnBeforeUnload);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('beforeunload', this.handleOnBeforeUnload);\n  }\n\n  handleOnBeforeUnload = ev => {\n    ev.preventDefault();\n    ev.returnValue = \"\";\n  }\n\n  // It's worth noting we only handle one competition over the life of the component,\n  // therefore no componentDidUpdate is necessary.\n  // To upload scrambles for another competition the user would just refresh the page.\n\n  uploadNewScramble = ev => {\n    let reader = new FileReader();\n\n    reader.onload = e => {\n      // TODO: some check we're facing well formatted scrambles\n      this.setState(state => {\n        let newScramble = JSON.parse(e.target.result)\n        // Manually assign some id, in case someone uses same name for zip\n        // but with different scrambles.\n        newScramble.competitionName = `${scrambleUploadedId++}: ${newScramble.competitionName}`;\n        newScramble = updateIn(newScramble, ['sheets'], updateMultiAndFm);\n        newScramble = transformUploadedScrambles(newScramble);\n        return {\n          wcif: {\n            ...state.wcif,\n            scrambleProgram: newScramble.version,\n          },\n          uploadedScrambles: [...state.uploadedScrambles, newScramble],\n        }\n      });\n    }\n\n    reader.onerror = e => {\n      alert(\"Couldn't load the JSON scrambles file\");\n    }\n\n    if (ev.target.files.length > 0)\n      reader.readAsText(ev.target.files[0]);\n  }\n\n  attachScramblesToRound = (scrambles, round) => {\n    const { wcif } = this.state;\n    let eventId = eventIdFromRound(round);\n    let eventIndex, roundIndex = null;\n    let event = wcif.events.find((e, index) => {\n      eventIndex = index;\n      return e.id === eventId;\n    });\n    event.rounds.find((r, index) => {\n      roundIndex = index;\n      return r.id === round.id;\n    });\n    this.setState({\n      wcif: updateIn(wcif, [\"events\", eventIndex, \"rounds\", roundIndex], r => {\n        return {\n          ...r,\n          scrambleSets: scrambles,\n        };\n      }),\n    });\n  }\n\n  handleWcifChange = wcif => this.setState({ wcif });\n\n  setSelectedRound = id => this.setState({ selectedRoundId: id });\n\n  render() {\n    const { wcif, selectedRoundId, uploadedScrambles } = this.state;\n    // const { handleWcifUpdate } = this.props;\n    const rounds = flatMap(wcif.events, e => e.rounds);\n    let availableScrambles = [];\n    let round = null;\n    let event = null;\n    if (selectedRoundId) {\n      round = rounds.find(r => r.id === selectedRoundId);\n      let eventId = eventIdFromRound(round);\n      event = wcif.events.find(e => e.id === eventId);\n      let used = usedScramblesIdsForEvent(wcif.events, event.id);\n      availableScrambles = allScramblesForEvent(uploadedScrambles, event.id, used);\n    }\n    return (\n      <Grid container>\n        <Grid item xs={12} style={{ padding: 16 }}>\n          <Typography variant=\"h2\" component=\"h1\" align=\"center\">\n            {wcif.name}\n          </Typography>\n        </Grid>\n        <Grid item xs={12} md={4} lg={3} xl={2} style={{ padding: 16 }}>\n          <CompetitionMenu events={wcif.events}\n            setSelectedRound={this.setSelectedRound} />\n        </Grid>\n        <Grid item xs={12} md={8} style={{ padding: 16 }}>\n          { round ? (\n            <RoundPanel event={event} round={round}\n              availableScrambles={availableScrambles}\n              attachScramblesToRound={this.attachScramblesToRound}\n            />\n          ) : (\n            <CompetitionInfo wcif={wcif} uploadedScrambles={uploadedScrambles}\n              uploadAction={this.uploadNewScramble}\n              handleWcifChange={this.handleWcifChange}\n              version={version}\n            />\n          )}\n        </Grid>\n      </Grid>\n    );\n  }\n};\n","\nexport const decodeMbldResult = value => {\n  if (value <= 0) return { solved: 0, attempted: 0, centiseconds: value };\n  const missed = value % 100;\n  const seconds = Math.floor(value / 100) % 1e5;\n  const difference = 99 - (Math.floor(value / 1e7) % 100);\n  const solved = difference + missed;\n  const attempted = solved + missed;\n  const centiseconds = seconds === 99999 ? null : seconds * 100;\n  return { solved, attempted, centiseconds };\n};\n\nexport const encodeMbldResult = ({ solved, attempted, centiseconds }) => {\n  if (centiseconds <= 0) return centiseconds;\n  const missed = attempted - solved;\n  const dd = 99 - (solved - missed);\n  const seconds = Math.round(\n    (centiseconds || 9999900) / 100\n  ); /* 99999 seconds is used for unknown time. */\n  return dd * 1e7 + seconds * 1e2 + missed;\n};\n\nconst timeInSecToValue = resultString =>\n  Math.round(parseFloat(resultString)*100);\n\nconst timeInMinutesToValue = resultString => {\n  let [min, rest] = resultString.split(\":\");\n  min = parseInt(min);\n  const centisec = timeInSecToValue(rest);\n  return min * 6000 + centisec;\n};\n\nexport const timeToValue = (resultString, asMove=false) => {\n  switch (resultString) {\n    case \"DNF\":\n      return -1;\n    case \"DNS\":\n      return -2;\n    default:\n      if (!resultString) {\n        return 0;\n      } else if (asMove) {\n        return parseInt(resultString);\n      } else if (resultString.includes(\":\")) {\n        return timeInMinutesToValue(resultString);\n      } else {\n        return timeInSecToValue(resultString);\n      }\n  }\n};\n\n","import { registrantIdFromAttributes } from './wcif';\nimport { timeToValue } from './results';\nimport { roundTypeFromCellName } from './roundtypes';\n\nconst formatStringToId = {\n  \"Format: best of 1\": \"1\",\n  \"Format: best of 2\": \"2\",\n  \"Format: best of 3\": \"3\",\n  \"Format: mean of 3\": \"m\",\n  \"Format: average of 5\": \"a\",\n  \"Format: average of 5 (removing best and worst)\": \"a\",\n};\n\nconst expectedNumberOfAttemptsByFormat = {\n  \"1\": 1,\n  \"2\": 2,\n  \"3\": 3,\n  \"m\": 3,\n  \"a\": 5,\n};\n\n// First two rows contain the competition name and irrelevant information.\n// Third row is these headers\n//[\"#\", \"Name\", \"Country\", \"WCA id\", \"Gender\", \"Date of birth\", ...]\nexport const personWcifFromRegistrationXlsx = sheet =>\n  sheet.splice(0, 3) && sheet.map(person => {\n    return {\n      registrantId: parseInt(person[0]),\n      name: person[1],\n      wcaUserId: null,\n      country: person[2],\n      wcaId: person[3] || null,\n      gender: person[4],\n      birthdate: person[5],\n      // We actually don't need to fill this to post results.\n      registration: {},\n      email: null,\n      avatar: null,\n      roles: [],\n      assignments: [],\n      personalBests: [],\n    };\n  });\n\nconst attemptsFromResultRow = (eventId, formatId, row) => {\n  let maxAttempts = expectedNumberOfAttemptsByFormat[formatId];\n  if (eventId === \"333mbf\") {\n    return [...Array(maxAttempts).keys()].map(index => {\n      return {\n        // For MBF there is a 4 column offset for the person,\n        // then each result takes 4 columns.\n        result: parseInt(row[7 + index*4]),\n      }\n    });\n  } else {\n    let attempts = row.slice(4, 4 + maxAttempts).filter(a => a).map(a => {\n      return {\n        result: timeToValue(a, eventId === \"333fm\"),\n      };\n    });\n    // Fillup to expected number of attempts.\n    // Not necessary but useful to export to results JSON.\n    while (attempts.length !== maxAttempts)\n      attempts.push({ result: 0 });\n    return attempts;\n  }\n};\n\nconst bestForRow = (eventId, formatId, row) => {\n  let maxAttempts = expectedNumberOfAttemptsByFormat[formatId];\n  if (formatId === \"1\") {\n    // Then there is no \"best\" column\n    return eventId === \"333mbf\"\n      ? parseInt(row[7])\n      : timeToValue(row[4], eventId === \"333fm\");\n  } else {\n    // Use extra offset for the \"best\" column\n    return eventId === \"333mbf\"\n      ? parseInt(row[4 + maxAttempts*4])\n      : timeToValue(row[4 + maxAttempts], eventId === \"333fm\");\n  }\n};\n\nconst avgForRow = (eventId, formatId, row) => {\n  if (eventId === \"333mbf\")\n    return 0;\n  // also get the average for the best of 3 format:\n  // the only events which can use it are 3bf, 4bf, 5bf, and 3mbf.\n  // Except for 3mbf, we recognize the average.\n  if ([\"3\", \"m\", \"a\"].includes(formatId)) {\n    let maxAttempts = expectedNumberOfAttemptsByFormat[formatId];\n    if (formatId === \"a\") {\n      // 5 would return the WR marker for the best.\n      // 6 would return the worst.\n      return timeToValue(row[7 + maxAttempts]);\n    } else {\n      // For FM mo3, the value doesn't need to be taken as moves!\n      // 5 would return the WR marker for the best.\n      return timeToValue(row[6 + maxAttempts]);\n    }\n  }\n\n  return 0;\n};\n\n\n// First row: round name\n// Second row: format name\n// Third row: time format\n// Fourth row:\n//   [\"Position\", \"Name\", \"Country\", \"WCA id\", \"1\", \"2\", \"3\", \"4\", \"5\", \"Best\", \"WR\", \"Worst\", \"Average\", \"WR\"]\n// or for multi:\n//   [\"Position\", \"Name\", \"Country\", \"WCA id\", \"tried\", \"solved\", \"seconds\", \"score 1\", \"WR\"]\nexport const roundWcifFromXlsx = (persons, eventId, roundNumber, sheet) => {\n  let roundFormat = formatStringToId[sheet[1][0]];\n  let roundType = roundTypeFromCellName(sheet[0][0]);\n  if (!roundFormat)\n    throw new Error(`Couldn't get format from string \"${sheet[1][0]}\"`);\n  if (!roundType)\n    throw new Error(`Couldn't get roundTypeId from string \"${sheet[0][0]}\"`);\n  sheet.splice(0, 4);\n  return {\n    advancementCondition: null,\n    id: `${eventId}-r${roundNumber}`,\n    roundTypeId: roundType.id,\n    cutoff: null,\n    format: roundFormat,\n    results: sheet.filter(row => row[1]).map(row => {\n      return {\n        ranking: parseInt(row[0]),\n        personId: registrantIdFromAttributes(persons, row[1], row[2], row[3] || null),\n        attempts: attemptsFromResultRow(eventId, roundFormat, row),\n        // these are *not* in the WCIF, but will make our life easier to export\n        // to results json!\n        best: bestForRow(eventId, roundFormat, row),\n        average: avgForRow(eventId, roundFormat, row),\n      };\n    }),\n    scrambleSetCount: 0,\n    scrambleSets: [],\n    timeLimit: null,\n  };\n};\n","import React from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport Button from '@material-ui/core/Button';\nimport Typography from '@material-ui/core/Typography';\nimport Paper from '@material-ui/core/Paper';\nimport Grid from '@material-ui/core/Grid';\nimport XLSX from 'xlsx';\nimport { personWcifFromRegistrationXlsx, roundWcifFromXlsx } from '../../logic/xlsx-utils';\n\n\n//import tmpWcif from '../../wcifresults.json';\n\nconst useStyles = makeStyles(theme => ({\n  input: {\n    display: 'none',\n  },\n  h: {\n    marginBottom: theme.spacing(3),\n  },\n  button: {\n    marginLeft: theme.spacing(3),\n  },\n}));\n\nconst loadSheetIntoWcif = (wcif, name, jsonSheet) => {\n  // This function strongly assumes that 'Registration' is the first sheet...\n  if (name === \"Registration\") {\n    wcif.name = jsonSheet[0][0];\n    wcif.shortName = wcif.name;\n    wcif.persons = personWcifFromRegistrationXlsx(jsonSheet);\n  } else {\n    // Cubecomps export numbers for round identification, CubingChina exports\n    // the roundTypeId.\n    let eventId = name.split(\"-\")[0];\n    let event = wcif.events.find(e => e.id === eventId);\n    if (!event) {\n      event = {\n        id: eventId,\n        rounds: [],\n        competitorLimit: null,\n        qualification: null,\n      };\n      wcif.events.push(event);\n    }\n    let roundNumber = event.rounds.length + 1;\n    event.rounds.push(roundWcifFromXlsx(wcif.persons, eventId, roundNumber, jsonSheet));\n  }\n};\n\nconst xlsxOptions = {\n  header: 1,\n  raw: false,\n  blankrows: false,\n};\n\nconst handleXlsxUploadChange = (updater, event) => {\n  const reader = new FileReader();\n\tconst rABS = !!reader.readAsBinaryString;\n\n  reader.onload = e => {\n    const wb = XLSX.read(e.target.result, {type:rABS ? 'binary' : 'array'});\n    const sheetNames = wb.SheetNames;\n    const wcif = {\n      // Unfortunately this is not included in the XLSX :(\n      id: null,\n      name: \"<undefined>\",\n      shortName: \"<undefined>\",\n      schedule: [],\n      events: [],\n      persons: [],\n    };\n    sheetNames.forEach(name => loadSheetIntoWcif(wcif, name, XLSX.utils.sheet_to_json(wb.Sheets[name], xlsxOptions)));\n    updater(wcif);\n  }\n\n  reader.onerror = e => alert(\"Couldn't load the JSON file\");\n\n  if(rABS)\n    reader.readAsBinaryString(event.target.files[0]);\n  else\n    reader.readAsArrayBuffer(event.target.files[0]);\n};\n\nconst handleFileUploadChange = (updater, event) => {\n\n  let reader = new FileReader();\n\n  reader.onload = e => updater(JSON.parse(e.target.result));\n\n  reader.onerror = e => alert(\"Couldn't load the JSON file\");\n\n  reader.readAsText(event.target.files[0]);\n};\n\nconst ImportWCIF = ({ handleWcifJSONLoad }) => {\n  const classes = useStyles();\n  // Dirty hack to preload given WCIF\n  //handleWcifJSONLoad(tmpWcif);\n  return (\n    <Grid container justify=\"center\">\n      <Grid item xs={12} md={8} lg={6} xl={6} style={{ padding: 16 }}>\n        <Paper style={{ padding: 16 }}>\n          <Typography variant=\"h2\" component=\"h1\" align=\"center\" className={classes.h}>\n            Scrambles Matcher\n          </Typography>\n          <Typography paragraph>\n            This tool enables you to assign sets of JSON scrambles generated by TNoodle\n            to a WCIF. You can either import an existing WCIF or import a results\n            spreadsheet (created by cubecomps) that will be converted to a WCIF.\n          </Typography>\n          <Typography color=\"error\" style={{ fontWeight: \"bold\" }}>\n            There is currently no check whatsoever on the imported data.\n            <br/>\n            If you upload incomplete results, or the wrong file on the wrong place,\n            the application will simply crash.\n            <br/>\n            If you refresh the page, you will have to start over.\n          </Typography>\n          <Grid container direction=\"row\" justify=\"center\">\n            <Typography variant=\"h6\" className={classes.h}>\n              Get started:\n            </Typography>\n            <input\n              accept=\".json\"\n              className={classes.input}\n              id=\"raised-button-file\"\n              multiple\n              type=\"file\"\n              onChange={ev => handleFileUploadChange(handleWcifJSONLoad, ev)}\n            />\n            <label htmlFor=\"raised-button-file\">\n              <Button component=\"span\"\n                variant=\"contained\"\n                color=\"primary\"\n                className={classes.button}\n              >\n                Upload WCIF\n              </Button>\n            </label>\n            <input\n              accept=\".xlsx\"\n              className={classes.input}\n              id=\"raised-button-xlsx\"\n              multiple\n              type=\"file\"\n              onChange={ev => handleXlsxUploadChange(handleWcifJSONLoad, ev)}\n            />\n            <label htmlFor=\"raised-button-xlsx\">\n              <Button component=\"span\"\n                variant=\"contained\"\n                color=\"primary\"\n                className={classes.button}\n              >\n                Upload XLSX\n              </Button>\n            </label>\n          </Grid>\n          <Typography paragraph>\n            You are most likely used to using the Workbook Assistant (WA).\n            For competition where everything went well and you just have one\n            single and comprehensive JSON scrambles file, then using this\n            should be almost like using the WA.\n            <br/>\n            If you have had to edit manually some scrambles JSON because of Multiple\n            Blindfolded, or if you have had to combine multiple scrambles JSONs, read on!\n            Here is a non exhaustive list of differences:\n          </Typography>\n          <Typography variant=\"h6\">\n            Additions\n          </Typography>\n          <ul>\n            <li>\n              \"Better\" scrambles matching.\n              <br/>\n              The WA re-assigns automatically scrambles each time\n              you upload a separate scrambles JSON.\n              Even if you already matched a round to its corresponding set in\n              the already uploaded scrambles.\n              Scrambles Matcher assigns on-demand, and will only try to associate\n              rounds which have no scrambles to scrambles from the uploaded JSON(s).\n            </li>\n            <li>\n              Better Drag and Drop for scrambles.\n              <br/>\n              If you have moved scrambles around in the WA you know what I'm talking\n              about.\n            </li>\n            <li>\n              Native support for attempt-based event.\n              <br/>\n              Namely Multiple Blindfolded and Fewest Moves.\n              When importing scrambles JSON(s) it will split scramble sheets for\n              these events into attempt, so that they can be matched\n              (manually or automatically) to the attempt they have actually\n              been used for.\n              <br/>\n              Especially useful if you had to generate a couple of extra\n              scrambles for Multiple Blindfolded, or simply if you used several\n              groups for that event.\n              <br/>\n              Then for the results JSON they are grouped together in a meaningful\n              way for the WCA website.\n            </li>\n            <li>\n              No more 100MB database download, no more java, just a html page to load.\n              However this leads to a missing feature (for now), see below.\n            </li>\n          </ul>\n          <Typography variant=\"h6\">\n            Missing feature\n          </Typography>\n          <ul>\n            <li>\n              No more newcomers check. It does mean you will have to upload\n              the results to the WCA website first, as it will validate the\n              list of competitors. Since you can download the Results JSON\n              even if you don't have assigned scrambles, you should be able\n              to check newcomers even before going through scrambles assignment.\n            </li>\n          </ul>\n        </Paper>\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default ImportWCIF;\n","import React, { Component } from 'react';\nimport CssBaseline from '@material-ui/core/CssBaseline';\nimport Competition from '../Competition/Competition';\nimport ImportWCIF from '../ImportWCIF/ImportWCIF';\nimport { ensureScramblesMember } from '../../logic/scrambles';\nimport { sortWcifEvents } from '../../logic/events';\nimport { updateIn } from '../../logic/utils';\n\n\nexport default class App extends Component {\n  state = {\n    wcif: null,\n    errors: []\n  };\n\n  handleWcifJSONLoad = json => {\n    let wcif = updateIn(json, ['events'], ensureScramblesMember)\n    wcif = updateIn(wcif, ['events'], sortWcifEvents);\n    this.setState({ wcif });\n  };\n\n  handleWcifUpdate = wcif => {\n    this.setState({ wcif });\n  };\n\n  render() {\n    const { wcif, errors } = this.state;\n    return (\n      <div style={{ display: 'flex', minHeight: '100vh', flexDirection: 'column' }}>\n        <CssBaseline />\n        {wcif ? (\n          <Competition handleWcifUpdate={this.handleWcifUpdate} wcif={wcif} />\n        ) : (\n          <ImportWCIF handleWcifJSONLoad={this.handleWcifJSONLoad} errors={errors} />\n        )}\n      </div>\n    );\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'typeface-roboto';\nimport './wca_data/cubing-icons.css';\n\nimport App from './components/App/App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}